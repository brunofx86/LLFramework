(** * System MALL for propositional multiplicative and additive linear logic

This file encodes the inference rules of the system MALL (two sided)
of propositional multiplicative additive linear logic.
 *)

Require Import LL.Misc.Permutations.
Require Export LL.OL.Substructural.OLCut.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

 
(** ** Syntax *)
(* No units *)
Inductive Constants := .
(* conjunction, disjunction and implication *)
Inductive Connectives := TENSOR | PAR | WITH | OPLUS .
(* no quantifiers *)
Inductive Quantifiers := .
(* no unary connectives *) 
Inductive UConnectives := .

#[local]Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    constants := Constants ;
    uconnectives := UConnectives;
    connectives := Connectives ;
    quantifiers := Quantifiers
  |}.


(** ** Inference rules *)

(** *** Constants *)
Definition rulesCTE (c:constants) :=
  match c return ruleCte with
  end.

(** *** Unary connectives *)
Definition rulesUC  (c:uconnectives) :=
  match c return ruleUnary with
  end.

(** *** Binary connectives *)
Definition rulesBC (c :connectives) :=
  match c with
  | TENSOR => {| rb_rightBody := fun F G => MAnd (atom (up F)) (atom (up G) );
                 rb_leftBody  := fun F G => MOr (atom (down F) ) (atom (down G)) |}
  | PAR => {| rb_rightBody := fun F G => MOr (atom (up F)) (atom (up G) );
              rb_leftBody  := fun F G => MAnd (atom (down F) ) (atom (down G)) |}
  | WITH => {| rb_rightBody := fun F G => AAnd (atom (up F)) (atom (up G) );
                 rb_leftBody  := fun F G => AOr (atom (down F) ) (atom (down G)) |}
  | OPLUS => {| rb_rightBody := fun F G => AOr (atom (up F)) (atom (up G) );
             rb_leftBody  := fun F G => AAnd (atom (down F) ) (atom (down G)) |}
  end.

(** *** Quantifiers *)
Definition rulesQC (c :quantifiers) :=
  match c return ruleQ with
  end.


#[local] Instance SimpleOORUles : OORules :=
  {|
    rulesCte := rulesCTE ;
    rulesUnary := rulesUC ;
    rulesBin := rulesBC;
    rulesQ := rulesQC
  |}.

(** ** Well-formedness conditions *)

(** *** Constants *)
Lemma wellFormedConstant_p : wellFormedCte.
Proof with sauto.
  unfold wellFormedCte;intros.
  destruct lab.
Qed.


(** *** Unary connectives *)

Lemma wellFormedUnary_p : wellFormedUnary.
Proof with sauto. 
  unfold wellFormedUnary;intros.
  destruct lab.
Qed.


(** *** Binary connectives *)
Lemma wellFormedBinary_p : wellFormedBinary.
Proof with sauto.
  unfold wellFormedBinary;intros.
  destruct lab;destruct s.
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  invTri H8.
  invTri H9.
  invTri H6.
  invTri H10.
    exists [⌊ Go1 ⌋;⌊ Fo1 ⌋ ].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    simpl. solveLL. 
    apply seqNtoSeq in H9...
    LLExact H9.
    lia.
    intros.
    TFocus ((makeLRuleBin TENSOR Fo1 Go1)).
    inversion H4.
    FLLsplit [⌊ t_bin TENSOR Fo1 Go1 ⌋] Delta1.
    simpl. solveLL. 
    LLExact H2.
  - 
    invTri H8.
    invTri H10.
    invTri H8.
    invTri H11.
    exists [⌊ Go1 ⌋;⌊ Fo1 ⌋].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    simpl. solveLL.
    apply seqNtoSeq in H10...
    LLExact H10.
    LLExact H10.
    rewrite H3...
    lia.
    intros.
    simpl. solveLL.
    LLExact H1.  
  +
  exists BTwoPM.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H10.
    invTri H11.
    invTri H9.
    invTri H10. 
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    rewrite H3...
    rewrite H4...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    apply seqNtoSeq in H11.
    LLExact H11.
    LLExact H12.
    LLExact H11.
    lia.
    intros.
    TFocus ((makeRRuleBin TENSOR Fo1 Go1)).
    inversion H6.
    FLLsplit [⌈ t_bin TENSOR Fo1 Go1 ⌉] ( Delta1 ++ Delta2).
    simpl...
    FLLsplit Delta1 Delta2.
    solveLL.
    LLExact H2.
    solveLL.
    LLExact H5.
  --
    invTri H8.
    invTri H11.
    invTri H12.
    invTri H10.
    invTri H11.
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉], [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H13.
    LLExact H13.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    LLExact H13.
    LLExact H12.
    lia.
    intros.
    simpl...
    FLLsplit Delta1 Delta2. 
    solveLL.
    LLExact H1.
    solveLL.
    LLExact H2.     
  +
  exists BTwoPM.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H10.
    invTri H11.
    invTri H9.
    invTri H10. 
    eexists M.
    eexists N0.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    rewrite H3...
    rewrite H4...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    apply seqNtoSeq in H11.
    LLExact H11.
    LLExact H12.
    LLExact H11.
    lia.
    intros.
    TFocus ((makeLRuleBin PAR Fo1 Go1)).
    inversion H6.
    FLLsplit [⌊ t_bin PAR Fo1 Go1 ⌋] ( Delta1 ++ Delta2).
    simpl...
    FLLsplit Delta1 Delta2.
    solveLL.
    LLExact H2.
    solveLL.
    LLExact H5.
  --
    invTri H8.
    invTri H11.
    invTri H12.
    invTri H10.
    invTri H11.
    eexists M.
    eexists N0.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H13.
    LLExact H13.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    LLExact H13.
    LLExact H12.
    lia.
    intros.
    simpl...
    FLLsplit Delta1 Delta2. 
    solveLL.
    LLExact H1.
    solveLL.
    LLExact H2.   
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  invTri H8.
  invTri H9.
  invTri H6.
  invTri H10.
    exists [⌈ Go1 ⌉; ⌈ Fo1 ⌉ ].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    simpl. solveLL. 
    apply seqNtoSeq in H9...
    LLExact H9.
    lia.
    intros.
    TFocus ((makeRRuleBin PAR Fo1 Go1)).
    inversion H4.
    FLLsplit [⌈ t_bin PAR Fo1 Go1 ⌉] Delta1.
    simpl. solveLL. 
    LLExact H2.
  - 
    invTri H8.
    invTri H10.
    invTri H8.
    invTri H11.
    exists [⌈ Go1 ⌉;⌈ Fo1 ⌉].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    simpl. solveLL.
    apply seqNtoSeq in H10...
    LLExact H10.
    LLExact H10.
    rewrite H3...
    lia.
    intros.
    simpl. solveLL.
    LLExact H1.  
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌊ Fo1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleBin WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin WITH Fo1 Go1 ⌋] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌊ Go1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleBin WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin WITH Fo1 Go1 ⌋] Delta1.
    FLLright.
    FLLrelease.
    FLLstore.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌊ Fo1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌊ Go1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.    
   +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeRRuleBin WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin WITH Fo1 Go1 ⌉] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11.
    LLExact H10.
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.    
       
       +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeLRuleBin OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin OPLUS Fo1 Go1 ⌋] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11.
    LLExact H10.
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.
       +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌈ Fo1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleBin OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin OPLUS Fo1 Go1 ⌉] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌈ Go1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleBin OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin OPLUS Fo1 Go1 ⌉] Delta1.
    FLLright.
    FLLrelease.
    FLLstore.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌈ Fo1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌈ Go1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.
Qed.

(** *** Quantifiers *)
Lemma wellFormedQuantifier_p : wellFormedQuantifier.
Proof with sauto.
  unfold wellFormedQuantifier. intros.
  destruct lab.
Qed.

Lemma wellFormedTheory_p : wellFormedTheory.
Proof.
  split.
  apply wellFormedConstant_p.
  split.
  apply wellFormedUnary_p.
  split; [apply wellFormedBinary_p | apply wellFormedQuantifier_p].
Qed.

(** ** Cut-coherency properties *)

(** *** Binary Connectives *)
Lemma CutCoherenceTENSOR: CutCoherenceBin (rulesBC TENSOR).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [⌈ F ⌉^] [⌊ F ⌋^ ⊗ ⌊ G ⌋^; ⌈ G ⌉^]   .
  all: solveLL.
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [⌈ G ⌉^] [⌊ F ⌋; ⌊ F ⌋^ ⊗ ⌊ G ⌋^]   .
  all:solveLL.
  LFocus (⌊ F ⌋^ ⊗ ⌊ G ⌋^) [⌊ G ⌋; ⌊ F ⌋].
  FLLsplit [⌊ F ⌋] [⌊ G ⌋]. 
Qed. 
  
Lemma CutCoherencePAR: CutCoherenceBin (rulesBC PAR).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [⌈ F ⌉^ ⊗ ⌈ G ⌉^; ⌊ G ⌋^]  [⌊ F ⌋^]  .
  all: solveLL.
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [⌈ F ⌉; ⌈ F ⌉^ ⊗ ⌈ G ⌉^] [⌊ G ⌋^]   .
  all:solveLL.
  LFocus (⌈ F ⌉^ ⊗ ⌈ G ⌉^) [⌈ G ⌉; ⌈ F ⌉].
  FLLsplit [⌈ F ⌉] [⌈ G ⌉]. 
Qed. 
  

Lemma CutCoherenceWITH: CutCoherenceBin (rulesBC WITH).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [⌈ F ⌉^ ⊕ ⌈ G ⌉^]  [⌊ F ⌋^]  .
  all: solveLL.
  LFocus (⌈ F ⌉^ ⊕ ⌈ G ⌉^) [⌈ F ⌉].
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [⌈ F ⌉^ ⊕ ⌈ G ⌉^] [⌊ G ⌋^]   .
  all:solveLL.
  LFocus (⌈ F ⌉^ ⊕ ⌈ G ⌉^) [⌈ G ⌉].
 
Qed. 


Lemma CutCoherenceOPLUS: CutCoherenceBin (rulesBC OPLUS).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [⌈ F ⌉^]   [⌊ F ⌋^ ⊕ ⌊ G ⌋^]  .
  all: solveLL.
  LFocus (⌊ F ⌋^ ⊕ ⌊ G ⌋^) [⌊ F ⌋].
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
   FLLsplit [⌈ G ⌉^]   [⌊ F ⌋^ ⊕ ⌊ G ⌋^]  .
  all: solveLL.
  LFocus (⌊ F ⌋^ ⊕ ⌊ G ⌋^) [⌊ G ⌋].
Qed. 

Lemma CutCoherence_p : CutCoherence .
Proof.
  split;intros. 
  destruct lab...
  split;intros; try destruct lab.
  split;intros; try destruct lab. 
  apply CutCoherenceTENSOR.
  apply CutCoherencePAR.
  apply CutCoherenceWITH.
  apply CutCoherenceOPLUS.
Qed.
 
(** The theory is well formed: cut-coherence holds and all the rules
are bipoles *)
Lemma wellTheory_p : wellTheory.
Proof. 
   split.
   exact  CutCoherence_p.
  exact wellFormedTheory_p.
Qed.

(* 
Notation "( th ) ⊢ B ';' L ⇑ F " := (seq th B L (UP F))  (at level 80).
Notation "( th ) n ⊢ B ';' L ⇑ F " := (seqN th n B L (UP F))  (at level 80).


Check OLCutElimination wellTheory_p.
 *)
(** ** Adequacy 

Now we prove that the encoding is sound and complete. For that, we
define the provability relation of MALL as an inductive definition *)

Notation "F *** G" := (t_bin TENSOR F G) (at level 10) .
Notation "F $$$ G" := (t_bin PAR F G) (at level 10) .
Notation "F 'ooo' G" := (t_bin OPLUS F G) (at level 10) .
Notation "F &* G" := (t_bin WITH F G) (at level 10) .

Record cutrule := {
  cut : bool   }.


Inductive MALLSeq {P} {n} : list uexp -> list uexp -> Prop :=
| MALLInit : forall F , MALLSeq [F] [F]
| MALLTensorR : forall L1 L2 L1' L2' F G, MALLSeq L1 (F :: L2) -> MALLSeq L1' (G :: L2') -> MALLSeq  (L1 ++ L1') (F *** G :: (L2 ++ L2'))
| MALLTensorL : forall L1 L2 F G, MALLSeq (F :: G :: L1) L2 -> MALLSeq (F *** G :: L1) L2
| MALLParR : forall L1 L2 F G, MALLSeq L1 (F :: G :: L2) -> MALLSeq L1 (F $$$ G :: L2)
| MALLParL :forall L1 L2 L1' L2' F G, MALLSeq (F :: L1) L2 -> MALLSeq (G :: L1') L2' -> MALLSeq (F $$$ G :: L1 ++ L1') (L2 ++ L2')
| MALLOpRE1 : forall L1 L2 F G, MALLSeq L1 (F :: L2) -> MALLSeq L1 (F ooo G :: L2)
| MALLOpRE2 : forall L1 L2 F G, MALLSeq L1 (G :: L2) -> MALLSeq L1 (F ooo G :: L2)
| MALLOpL : forall L1 L2 F G, MALLSeq (F :: L1) L2 -> MALLSeq (G :: L1) L2 -> MALLSeq (F ooo G :: L1) L2
| MALLWithR : forall L1 L2 F G, MALLSeq L1 (F :: L2) -> MALLSeq L1 (G :: L2) -> MALLSeq L1 (F &* G :: L2)
| MALLWithL1 : forall L1 L2 F G, MALLSeq (F :: L1) L2 ->  MALLSeq (F &* G :: L1) L2
| MALLWithL2 : forall L1 L2 F G, MALLSeq (G :: L1) L2 ->  MALLSeq (F &* G :: L1) L2
| MALLExR : forall  L1 L2 L2', Permutation L2 L2' -> MALLSeq L1 L2' -> MALLSeq L1 L2
| MALLExL : forall  L1 L2 L1', Permutation L1 L1' -> MALLSeq L1' L2 -> MALLSeq L1 L2
| MALLCut {f : cut P = true}: forall F L1 L2 R1 R2, lengthUexp F n ->  isOLFormula F -> MALLSeq (F::L1) R1 -> MALLSeq L2 (F::R2) -> MALLSeq (L1++L2) (R1++R2).

Definition wc := {| cut:= true |}. (* with cut *)
Definition wnc :=  {| cut:= false |}. (* with no cut *)


Global Instance MALLL_morph w n: 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> iff) (MALLSeq (P:=w) (n:=n)).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply MALLExR with (L2':=x0);auto.
  eapply MALLExL with (L1':=x);auto.
  eapply MALLExR with (L2':=y0);auto.
  eapply MALLExL with (L1':=y);auto. 
Qed.

Local Hint Constructors MALLSeq : core.

Theorem SoundnessMALL: forall n L1 L2, 
                   MALLSeq (P:=wnc) (n:=n) L1 L2 -> MALLSeq (P:=wc) (n:=n) L1 L2.
Proof with sauto. 
    intros *. 
    intros HM.
   induction HM;simpl...
   rewrite H...
  rewrite H...
Qed.

 
Theorem SoundenessFLL: forall n L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wnc) (n:=n) L1 L2 ->
                                seq (OLTheory nPnN) []  ( (LEncode L1) ++  (REncode L2)) (UP []).
Proof with sauto; try OLSolve. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
  + TFocus (RINIT F).
      inversion H.
     apply ooth_init.
     inversion isFL2...
     FLLsplit [⌈ F ⌉] [⌊ F ⌋] ;solveLL.
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleBin TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F *** G ⌉] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉:: ⌜ L2 ⌝).
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
   LLPerm (⌞ L1' ⌟ ++ ⌈ G ⌉ :: ⌜ L2' ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleBin TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F *** G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌊ F ⌋ :: ⌊ G ⌋ :: ⌞ L1 ⌟ ++ ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleBin PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F $$$ G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleBin PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F $$$ G ⌋ ] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 

   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F ooo G ⌋ ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [ ⌈ F &* G ⌉  ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝) .
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + rewrite H in isFL2. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌈ x ⌉) ) in H.
      rewrite H. apply IHHM...
  + rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H. apply IHHM...
Qed.

Require Import LL.SL.FLL.Reasoning.
  
Theorem CompletenessFLL: forall x n L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                 seqN (OLTheory nPnN) x []  ( (LEncode L1) ++  (REncode L2)) (UP []) ->
                 MALLSeq (P:=wnc) (n:=n) L1 L2.
Proof with sauto;try solveLL; try OLSolve.
  induction x using lt_wf_ind; intros *.  
  intros HisL1 HisL2  Hseq. 
  inversion Hseq...
 cut(False);intros...
 refine (onlyAtomsLinear _ H0 H1)...
 apply isOLLEncode... 
 apply isOLREncode...
  inversion H1...
  inversion H3...
  1-4:  destruct C...
  3-4:  destruct C...
 + apply FocusingClause in H2...
    apply checkEncodeCasesU in H7... 
    apply OLInPermutation' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingTensor in H8... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLTensorR.
         eapply H with (m:=x2)...
         inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
        inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPar in H8... 
          eapply MALLParR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLWithR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H10.
         rewrite <- H5...
    ++ apply FocusingPlus in H8... 
          eapply MALLOpRE1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
          eapply MALLOpRE2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
 + apply FocusingClause in H2...
    apply checkEncodeCasesD in H7... 
    apply OLInPermutationL' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingPar in H8... 
          eapply MALLTensorL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingTensor in H8... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLParL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPlus in H8... 
          eapply MALLWithL1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
          eapply MALLWithL2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLOpL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H10.
         rewrite <- H5...
 + apply FocusingInitRuleU in H2...
     simpl in H4. 
    apply checkEncodeCasesU in H4...
    assert(In (⌊ OO ⌋) (⌜ L2 ⌝)).
    rewrite H2. rewrite H7.
    firstorder.
   apply NoDinR in H4...
   rewrite H7 in H2...
   assert(L1 = [OO]).
   eapply MapLEncodeEqual... 
   assert(L2 = [OO]).
   eapply MapREncodeEqual...
   rewrite H4, H5...
Qed.

Theorem SoundenessCFLL: forall x L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wc) (n:=x) L1 L2 ->
                          exists n,  x <= n /\ seq (OLTheoryCut nPnN n) []  ( (LEncode L1) ++  (REncode L2)) (UP []).
Proof with sauto; try OLSolve. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
  + eexists... TFocus (RINIT F).
      inversion H.
     apply oothc_theory.
     apply ooth_init.
     inversion isFL2...
     FLLsplit [⌈ F ⌉] [⌊ F ⌋] ;solveLL.
  + simpl in IHHM1,IHHM2...
     case IHHM1...
     inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
     intros...
     case IHHM2...
     inversion isFL2...
     inversion H3...
     inversion H...
     inversion isFL2...
     intros...
     eexists (x0+x1)... 
     TFocus (makeRRuleBin TENSOR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F *** G ⌉] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉:: ⌜ L2 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
   LLPerm (⌞ L1' ⌟ ++ ⌈ G ⌉ :: ⌜ L2' ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
  + simpl in IHHM...
     case IHHM.
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion H1...
     inversion H...
     inversion isFL1...
     intros...
     exists x0...   
     TFocus (makeLRuleBin TENSOR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F *** G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌊ F ⌋ :: ⌊ G ⌋ :: ⌞ L1 ⌟ ++ ⌜ L2 ⌝)...
  + simpl in IHHM...
     case IHHM.
     inversion isFL2...
      inversion isFL2...
     inversion H1...
     inversion H...
     inversion H1...
     inversion H...
     intros...
     exists x0...   
     TFocus (makeRRuleBin PAR F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F $$$ G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌈ G ⌉ :: ⌜ L2 ⌝)...
  + simpl in IHHM1,IHHM2...
     case IHHM1...
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
     intros...
     case IHHM2...
     inversion isFL1...
     inversion H3...
     inversion H...
     inversion isFL1...
     intros...
     eexists (x0+x1)... 
     TFocus (makeLRuleBin PAR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F $$$ G ⌋ ] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
  + simpl in IHHM...
     case IHHM.
     inversion isFL2...
      inversion isFL2...
     inversion H1...
     inversion H...
     intros...
     exists x0...   
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝)...
  + simpl in IHHM...
     case IHHM.
     inversion isFL2...
      inversion isFL2...
     inversion H1...
     inversion H...
     intros...
     exists x0...   
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝)...
  + simpl in IHHM1,IHHM2...
     case IHHM1...
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
     intros...
     case IHHM2...
     inversion isFL1...
     inversion H3...
     inversion H...
     inversion isFL1...
     intros...
     eexists (x0+x1)... 
     TFocus (makeLRuleBin OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F ooo G ⌋ ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
  + simpl in IHHM1,IHHM2...
     case IHHM1...
     inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
     intros...
     case IHHM2...
     inversion isFL2...
     inversion H3...
     inversion H...
     inversion isFL2...
     intros...
     eexists (x0+x1)...
     TFocus (makeRRuleBin WITH F G). 
     inversion H.
   apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [ ⌈ F &* G ⌉  ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝) .
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
  LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
  + simpl in IHHM...
     case IHHM.
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
     intros...
     exists x0...   
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
  + simpl in IHHM...
     case IHHM.
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
     intros...
     exists x0...   
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
  + simpl in IHHM...
     case IHHM...
     intros...
     exists x0...   
     rewrite H in isFL2. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌈ x ⌉) ) in H.
      rewrite H... 
  + simpl in IHHM...
     case IHHM...
     intros...
     exists x0...   
     rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H... 
   + simpl in IHHM1,IHHM2...
     case IHHM1...
     inversion isFL2...
     intros... 
     case IHHM2...
     inversion isFL2...
     intros...
     eexists (x0+x1)...
     TFocus (RCUT F).
     inversion H1.
    eapply oothc_cutn.
    eapply ctn with (m:=x)...
    FLLsplit ( ⌞ L2 ⌟ ++ ⌜ R2 ⌝) (⌞ L1 ⌟ ++ ⌜ R1 ⌝) .
    rewrite LEncodeApp, REncodeApp...
    1-2: solveLL.
  
    LLPerm (⌞ L2 ⌟ ++ ⌈ F ⌉ :: ⌜ R2 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...

   LLPerm (⌊ F ⌋ :: ⌞ L1 ⌟ ++ ⌜ R1 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
Qed.

Theorem CutElimMALL: forall x L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wc) (n:=x) L1 L2 -> MALLSeq (P:=wnc) (n:=x) L1 L2.
Proof with sauto.
 intros.
 apply  SoundenessCFLL in H1...
 specialize(OLCutElimination wellTheory_p);intros.
 apply seqtoSeqN in H3...
 apply H1 in H3... all:clear H1.
 apply seqtoSeqN in H3...
eapply CompletenessFLL with (n:=x) in H3...
apply Forall_app...
apply isOLLEncode...
apply isOLREncode...
Qed.
 

Lemma OLFormulaLeng F: isOLFormula F -> exists x, lengthUexp F x.
Proof with sauto.
 intro H. induction H;intros...
 - eexists...
 - inversion H...
    eexists...
 - eexists (S x)...
 - eexists (S (x0+x))...
 - assert(proper  (Var 0%nat)). 
    apply proper_VAR. 
    apply H1 in H2... 
    eexists (S x)...
Qed.
   
