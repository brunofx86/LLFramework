Require Import LL.FOLL.Dyadic.Tactics.
Set Implicit Arguments.

Import DyadicTactics.
Section InvRules.
   Context `{OLS: OLSig}.

Lemma invertibility_botN : forall n B M, LL2N n B  (Bot::M) -> LL2N n B  M.
Proof with sauto.
  induction n ;intros...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop x.
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop x.
    + checkPermutationCases H1.
        LLleft F G x.
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLright F G x.
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLwith F G x.
        1-2: eapply IHn. 
        1-2: rewrite perm_swap. 1-2: rewrite <- H1...
    + checkPermutationCases H1.
        rewrite H4...
        refine (LL2_HeightGeq H2 _)...
        rewrite H3. rewrite <- H1. 
        refine (LL2_HeightGeq H2 _)...
    + checkPermutationCases H1.
        LLpar F G x.
        eapply IHn.
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::⊥ :: x)... 
        rewrite <- H1...
   + checkPermutationCases H1.
       checkPermutationCases H1.
        LLtensor F G x0 N .
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
        LLtensor F G M0 x0 .
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
        LLstore F x.
        eapply IHn. rewrite <- H1...
   + checkPermutationCases H1.
       LLexists t FX x. 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       LLforall FX x. 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + LLcopy F.
        eapply IHn. 
        rewrite perm_swap... 
Qed.

Lemma invertibility_parN : forall n B M F G, 
                            LL2N n B  (F ⅋ G::M) -> LL2N n B  (F::G::M).
Proof with sauto.
  induction n ;intros...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (F::G::x). rewrite H2...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (F::G::x). rewrite H2...
    + checkPermutationCases H1.
        LLleft F0 G0 (F::G::x). rewrite H3...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::F0 :: x)... 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLright F0 G0 (F::G::x). rewrite H3...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::G0 :: x)... 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLwith F0 G0 (F::G::x). rewrite H4...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::F0 :: x)... 
        2: eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::G0 :: x)... 
        1-2: eapply IHn. 
        1-2: rewrite perm_swap. 1-2: rewrite <- H1...
    + checkPermutationCases H1.
        LLbot (F::G::x). rewrite H3...
        eapply IHn. rewrite <- H1... 
    + checkPermutationCases H1.
       { inversion H3...
          rewrite H4.
                  refine (LL2_HeightGeq H2 _)... }
       { LLpar F0 G0 (F::G::x). rewrite H3...
          eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::F0 :: G0::x)... 
          eapply IHn. 
          eapply LL2N_compat with (B1:=B) (L1:=F0 :: G0::(F ⅋ G) ::x)... 
            rewrite <- H1... }
   + checkPermutationCases H1.
       checkPermutationCases H1.
        LLtensor F0 G0 (F::G::x0) N . rewrite H4... rewrite <- H5...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::F0 ::x0)... 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
        LLtensor F0 G0 M0 (F::G::x0) . rewrite H4... rewrite <- H5...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::G0 ::x0)... 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
        LLstore F0 (F::G::x). rewrite H3...
        eapply IHn. rewrite <- H1...
   + checkPermutationCases H1.
       LLexists t FX (F::G::x).
       rewrite H5... 
       eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::FX t ::x)... 
         eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       LLforall FX (F::G::x).
       rewrite H4... 
       eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::FX x0 ::x)... 
         eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + LLcopy F0.
        eapply LL2N_compat with (B1:=B) (L1:=  F :: G ::F0 ::M)... 
        eapply IHn.
        rewrite perm_swap... 
Qed.


Lemma invertibility_storeN : forall n B M F,
                            LL2N n B  (? F::M) -> LL2N n (F::B)  M.
Proof with sauto.
  induction n ;intros...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop x.
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop x. 
    + checkPermutationCases H1.
        LLleft F0 G x. 
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLright F0 G x.  
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLwith F0 G x.  
        1-2: eapply IHn. 
        1-2: rewrite perm_swap. 1-2: rewrite <- H1...
    + checkPermutationCases H1.
        LLbot x. 
        eapply IHn. rewrite <- H1... 
    + checkPermutationCases H1.
        LLpar F0 G x.  
          eapply IHn. 
          eapply LL2N_compat with (B1:=B) (L1:=F0 :: G:: ? F::x)... 
            rewrite <- H1... 
   + checkPermutationCases H1.
       checkPermutationCases H1.
        LLtensor F0 G x0 N .  
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
        apply LL2weakeningN...
        LLtensor F0 G M0 x0 . 
        apply LL2weakeningN...
        eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       { inversion H3...
          rewrite H4.
         refine (LL2_HeightGeq H2 _)...  }
       { LLstore F0 x.
         rewrite perm_swap. 
          eapply IHn. 
            rewrite <- H1... }
   + checkPermutationCases H1.
       LLexists t FX x.
         eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       LLforall FX x.
         eapply IHn. 
        rewrite perm_swap. rewrite <- H1...
    + LLcopy F0...
        eapply IHn.
        rewrite perm_swap... 
Qed.
   

Lemma invertibility_withN : forall n B M F G, 
     LL2N n B (F & G::M) -> LL2N n B (F::M) /\ LL2N n B (G::M).
Proof with sauto.
  induction n ;intros...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (F::x). rewrite H2...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (G::x). rewrite H2...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (F::x). rewrite H2...
    + checkPermutationCases H1.
        LLleft F0 G0 (F::x). rewrite H3...
        rewrite perm_swap.
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLright F0 G0 (F::x). rewrite H3...
        rewrite perm_swap.
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
       { inversion H4...
          rewrite H5. refine (LL2_HeightGeq H2 _)...   }
       { LLwith F0 G0 (F::x). rewrite H4...
         rewrite perm_swap.
         eapply IHn with (F:=F) (G:=G). 
         rewrite perm_swap. rewrite <- H1...
         rewrite perm_swap.
         eapply IHn with (F:=F) (G:=G). 
         rewrite perm_swap. rewrite <- H1... }
    + checkPermutationCases H1.
        LLbot (F::x). rewrite H3...
        eapply IHn with (F:=F) (G:=G). 
         rewrite <- H1... 
    + checkPermutationCases H1.
       LLpar F0 G0 (F::x). rewrite H3...
        eapply LL2N_compat with (B1:=B) (L1:=  F :: F0 :: G0::x)... 
        eapply IHn with (F:=F) (G:=G). 
          eapply LL2N_compat with (B1:=B) (L1:=F0 :: G0::(F & G) ::x)... 
            rewrite <- H1... 
   + checkPermutationCases H1.
       checkPermutationCases H1.
        LLtensor F0 G0 (F::x0) N . rewrite H4... rewrite <- H5...
        rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
        LLtensor F0 G0 M0 (F::x0) . rewrite H4... rewrite <- H5...
        rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
        LLstore F0 (F::x). rewrite H3...
        eapply IHn with (F:=F) (G:=G). 
        rewrite <- H1...
   + checkPermutationCases H1.
       LLexists t FX (F::x).
       rewrite H5... 
        rewrite perm_swap. 
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       LLforall FX (F::x).
       rewrite H4... 
        rewrite perm_swap. 
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...

   + LLcopy F0.
      rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G).
        rewrite perm_swap...
   - inversion H...
    + checkPermutationCases H0.
    + checkPermutationCases H0.
        LLtop (G::x). rewrite H2...
    + checkPermutationCases H1.
        LLleft F0 G0 (G::x). rewrite H3...
        rewrite perm_swap.
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
        LLright F0 G0 (G::x). rewrite H3...
        rewrite perm_swap.
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
    + checkPermutationCases H1.
       { inversion H4...
          rewrite H5. refine (LL2_HeightGeq H3 _)... }  
       { LLwith F0 G0 (G::x). rewrite H4...
         rewrite perm_swap.
         eapply IHn with (F:=F) (G:=G). 
         rewrite perm_swap. rewrite <- H1...
         rewrite perm_swap.
         eapply IHn with (F:=F) (G:=G). 
         rewrite perm_swap. rewrite <- H1... }
    + checkPermutationCases H1.
        LLbot (G::x). rewrite H3...
        eapply IHn with (F:=F) (G:=G). 
         rewrite <- H1... 
    + checkPermutationCases H1.
       LLpar F0 G0 (G::x). rewrite H3...
        eapply LL2N_compat with (B1:=B) (L1:=  G :: F0 :: G0::x)... 
        eapply IHn with (F:=F) (G:=G). 
          eapply LL2N_compat with (B1:=B) (L1:=F0 :: G0::(F & G) ::x)... 
            rewrite <- H1... 
   + checkPermutationCases H1.
       checkPermutationCases H1.
        LLtensor F0 G0 (G::x0) N . rewrite H4... rewrite <- H5...
        rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
        LLtensor F0 G0 M0 (G::x0) . rewrite H4... rewrite <- H5...
        rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
        LLstore F0 (G::x). rewrite H3...
        eapply IHn with (F:=F) (G:=G). 
        rewrite <- H1...
   + checkPermutationCases H1.
       LLexists t FX (G::x).
       rewrite H5... 
        rewrite perm_swap. 
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...
   + checkPermutationCases H1.
       LLforall FX (G::x).
       rewrite H4... 
        rewrite perm_swap. 
        eapply IHn with (F:=F) (G:=G). 
        rewrite perm_swap. rewrite <- H1...

   + LLcopy F0.
      rewrite perm_swap.  
        eapply IHn with (F:=F) (G:=G).
        rewrite perm_swap...
Qed.

Lemma invertibility_forallN : forall n B FX M, 
     LL2N n B (∀{ FX}::M) -> (forall x : expr con, proper x -> LL2N n B (FX x :: M)).
Proof with sauto.
  induction n ;intros...
   - inversion H...
    + checkPermutationCases H1.
    + checkPermutationCases H1.
        LLtop (FX x::x0). rewrite H3...
   - inversion H...
    + checkPermutationCases H1.
    + checkPermutationCases H1.
        LLtop (FX x::x0). rewrite H3...
    + checkPermutationCases H2.
        LLleft F G (FX x::x0). rewrite H4...
        rewrite perm_swap.
        eapply IHn... 
        rewrite perm_swap. rewrite <- H2...
    + checkPermutationCases H2.
        LLright F G (FX x::x0). rewrite H4...
        rewrite perm_swap.
        eapply IHn... 
        rewrite perm_swap. rewrite <- H2...
    + checkPermutationCases H2.
         LLwith F G (FX x::x0). rewrite H5...
         rewrite perm_swap.
         eapply IHn... 
         rewrite perm_swap. rewrite <- H2...
         rewrite perm_swap.
         eapply IHn...  
         rewrite perm_swap. rewrite <- H2... 
    + checkPermutationCases H2.
        LLbot (FX x::x0). rewrite H4...
        eapply IHn... 
         rewrite <- H2... 
    + checkPermutationCases H2.
       LLpar F G (FX x::x0). rewrite H4...
        eapply LL2N_compat with (B1:=B) (L1:=  FX x :: F :: G::x0)... 
        eapply IHn... 
          eapply LL2N_compat with (B1:=B) (L1:=F:: G::∀{ FX} ::x0)... 
            rewrite <- H2... 
   + checkPermutationCases H2.
       checkPermutationCases H2.
        LLtensor F G (FX x::x1) N . rewrite H5... rewrite <- H6...
        rewrite perm_swap.  
        eapply IHn... 
        rewrite perm_swap. rewrite <- H2...
        LLtensor F G M0 (FX x::x1) . rewrite H5... rewrite <- H6...
        rewrite perm_swap.  
        eapply IHn...  
        rewrite perm_swap. rewrite <- H2...
   + checkPermutationCases H2.
        LLstore F (FX x::x0). rewrite H4...
        eapply IHn... 
        rewrite <- H2...
   + checkPermutationCases H2.
       LLexists t FX0 (FX x::x0).
       rewrite H6... 
        rewrite perm_swap. 
        eapply IHn...  
        rewrite perm_swap. rewrite <- H2...
   + checkPermutationCases H2.
       { inversion H5...
          pose proof (H4 x H0).
          rewrite H6... refine (LL2_HeightGeq H1 _)...  }
       {    LLforall FX0 (FX x::x0).
       rewrite H5... 
        rewrite perm_swap. 
        eapply IHn...  
        rewrite perm_swap. rewrite <- H2... }
   + LLcopy F.
      rewrite perm_swap.  
        eapply IHn...
        rewrite perm_swap...
Qed.
   
End InvRules.
