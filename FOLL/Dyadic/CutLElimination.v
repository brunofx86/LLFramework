Require Export LL.FOLL.Dyadic.Tactics.
Set Implicit Arguments.

Import DyadicTactics.
Section CutLElimination.
  Context `{OLS: OLSig}.

Tactic Notation "cutH2" constr(P1) constr(P2) :=
   let tP1 := type of P1 in
   let H' := fresh "HCUT" in
   match tP1 with
   | LL2N ?x ?BX (?CF::?CX) => let tP2 := type of P2 in
                    match tP2 with 
                    | LL2N ?y ?BX (_::?CY) =>  
                           assert(H': tP1 -> tP2 -> LL2S BX (CX++CY));
                           applyCutH; try rewrite app_nil_r in H' 
                    | _ => idtac "type of " P2 " is " tP2 end
   | LL2N ?x ?BX (?NF::?CF::?CX2) => let tP2 := type of P2 in
                    match tP2 with 
                    | LL2N ?y ?BX (_::?CY) =>  
                           assert(LL2N x BX (CF::(NF++CX2)) -> tP2 -> LL2S BX ((NF::CX2)++CY));  applyCutH; try rewrite app_nil_r in H' 
                    | _ => idtac "type of " P2 " is " tP2 end
   
   | _ => idtac "type of " P1 " is " tP1 end.                 
   
Theorem CutL i j C M N B : CutH (complexity C) (i+j) -> CutW (complexity C ) ->
 LL2 i |-- B; C::M ->
 LL2 j |-- B; (dual C)::N ->
 LL2 |-- B; M ++ N.
Proof with sauto; try dualSimpl.   
 intros CH CW Hi Hj.
 inversion Hi;subst.
 * checkPermutationCases H...
   solvell2.
   inversion H...
   solvell2.
 * inversion Hj...
   - checkPermutationCases H.
   - checkPermutationCases H.
     rewrite H1.
     LLtop x.
   - checkPermutationCases H.
     rewrite H2.
     LLleft F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH2 H0 Hi...
   - checkPermutationCases H.
     rewrite H2.
     LLright F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
   - checkPermutationCases H.
     rewrite H3.
     LLwith F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
     rewrite H in H1.
     putFirst H1 Bot.
     cutH H1 Hi...
   - checkPermutationCases H.
     rewrite H3.
     solvell2.
     rewrite H2.
     LLbot x;try solvell2.
     rewrite H in H0.
     cutH H0 Hi... exact Bot.
   - checkPermutationCases H.
     rewrite H2.
     LLpar F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...        
   - checkPermutationCases H.
     checkPermutationCases H.
     rewrite H3.
     rewrite <- H4.
     LLtensor F G x0 N0;try solvell2.
     rewrite H in H0. 
     putFirst H0 Bot. 
     cutH H0 Hi... 
     rewrite H3.
     rewrite <- H4.
     LLtensor F G M x0;try solvell2.
     rewrite H in H1.
     putFirst H1 Bot.
     cutH H1 Hi...
   - checkPermutationCases H.
     rewrite H2.
     LLstore F x;try solvell2.
     rewrite H in H0.
     assert(LL2 n |-- F::B; Bot::x ->
            LL2 i |-- F::B; [One] ->
            LL2 |-- F::B; x++[]).
     eapply CH...
     rewrite app_nil_r in H1. 
     apply H1...
   - checkPermutationCases H.
     rewrite H4.
     LLexists t FX x.
     rewrite H in H2.
     putFirst H2 Bot.
     cutH H2 Hi...
   - checkPermutationCases H.
     rewrite H3.
     LLforall FX x. 
     apply H1 in H2.
     rewrite H in H2.
     putFirst H2 Bot.
     cutH H2 Hi...
   - LLcopy F.
     simpl in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
 * checkPermutationCases H...
 
   2:{ rewrite H1.
       rewrite <- app_comm_cons...
       LLtop (x++N). }
   clear H2.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H1.
       LLtop (M++x).
     + checkPermutationCases H.
       rewrite H2.
       LLleft F G (M++x).
       rewrite H in H0...
       putFirst H0 Zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LLright F G (M++x).
       rewrite H in H0...
       putFirst H0 Zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLwith F G (M++x).
       rewrite H in H0.
       putFirst H0 Zero.
       cutH Hi H0...
       rewrite <- Permutation_midle...
       rewrite H in H1.
       putFirst H1 Zero.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LLbot (M++x).
       rewrite H in H0...
       cutH Hi H0...
       exact Zero.
     + checkPermutationCases H.
       rewrite H2. 
       LLpar F G (M++x).
       rewrite H in H0.
       putFirst H0 Zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H3.
       rewrite <- H4.
       LLtensor F G (M++x0) N0;try solvell2.
       rewrite H in H0...
       putFirst H0 Zero.
       cutH Hi H0...
       rewrite <- Permutation_midle...
     
       rewrite H3.
       rewrite <- H4.
       LLtensor F G M1 (M++x0);try solvell2.
       rewrite H in H1...
       putFirst H1 Zero.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LLstore F (M++x).
       rewrite H in H0.
       assert(LL2 i |-- F::B; Top :: M ->
            LL2 n |-- F::B; (dual Top)::x ->
            LL2 |-- F::B; M++x).
       eapply CH ...
       apply H1...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H4.
       LLexists t FX (M++x).
       rewrite H in H2.
       putFirst H2 Zero.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLforall FX (M++x).
       apply H1 in H2.
       rewrite H in H2.
       putFirst H2 Zero.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + LLcopy F.
       putFirst H0 (dual Top).
       cutH Hi H0...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
 
   2:{ rewrite H2.
       LLleft F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H2.
       LLtop (M++x).   
     + checkPermutationCases H.
       rewrite H3.
       LLleft F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLright F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4... 
       rewrite H5.
       cutW H0 H1...
       simpl...
       rewrite H4.
       LLwith F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (dual F & dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...     
     + checkPermutationCases H.
       rewrite H3.
       LLbot (M++x).
       rewrite H in H1...
       cutH Hi H1...   
     + checkPermutationCases H.
       rewrite H3. 
       LLpar F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (dual F & dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
    + checkPermutationCases H.
       rewrite H3.
       LLstore F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F ⊕ G) :: M ->
            LL2 n0 |-- F0::B; dual (F ⊕ G)::x ->
            LL2 |-- F0::B; M++x).
       eapply CH...
       apply H2...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H5.
       LLexists t FX (M++x).
       rewrite H in H3.
       putFirst H3 (dual F & dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLforall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 (dual F & dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + LLcopy F0.
       putFirst H1 (dual (F ⊕ G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
* checkPermutationCases H...
 
   2:{ rewrite H2.
       LLright F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H2.
       LLtop (M++x).   
     + checkPermutationCases H.
       rewrite H3.
       LLleft F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLright F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4... 
       rewrite H5.
       cutW H0 H2...
       simpl...
       rewrite H4.
       LLwith F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (dual F & dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...     
     + checkPermutationCases H.
       rewrite H3.
       LLbot (M++x).
       rewrite H in H1...
       cutH Hi H1...   
     + checkPermutationCases H.
       rewrite H3. 
       LLpar F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (dual F & dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (dual F & dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
    + checkPermutationCases H.
       rewrite H3.
       LLstore F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F ⊕ G) :: M ->
            LL2 n0 |-- F0::B; dual (F ⊕ G)::x ->
            LL2 |-- F0::B; M++x).
       eapply CH...
       apply H2...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H5.
       LLexists t FX (M++x).
       rewrite H in H3.
       putFirst H3 (dual F & dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLforall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 (dual F & dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + LLcopy F0.
       putFirst H1 (dual (F ⊕ G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
 
   2:{ rewrite H3.
       LLwith F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj...
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj... }
   rewrite <- H4 in H0.
   rewrite <- H4 in H1.
   clear H4.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H3.
       LLtop (M++x).     
     + checkPermutationCases H.
       inversion H4...
       cutW H0 H2...
       simpl...
       rewrite H5...
       rewrite H4.
       LLleft F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (dual F ⊕ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4...
       cutW H1 H2...
       simpl...
       rewrite H5...
       rewrite H4.
       LLright F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (dual F ⊕ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLwith F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (dual F ⊕ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H in H3.
       putFirst H3 (dual F ⊕ dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...    
     + checkPermutationCases H.
       rewrite H4.
       LLbot (M++x).
       rewrite H in H2...
       cutH Hi H2...
     + checkPermutationCases H.
       rewrite H4. 
       LLpar F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (dual F ⊕ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H5.
       rewrite <- H6.
       LLtensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H2.
       putFirst H2 (dual F ⊕ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H5.
       rewrite <- H6.
       LLtensor F0 G0  M1 (M++x0);try solvell2.
       rewrite H in H3.
       putFirst H3 (dual F ⊕ dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLstore F0 (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F0::B; (F & G) :: M ->
            LL2 n0 |-- F0::B; dual (F & G)::x ->
            LL2 |-- F0::B; M++x).
       eapply CH...
       apply H3...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H6.
       LLexists t FX (M++x).
       rewrite H in H4.
       putFirst H4 (dual F ⊕ dual G).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLforall FX (M++x).
       apply H3 in H4.
       rewrite H in H4.
       putFirst H4 (dual F ⊕ dual G).
       cutH Hi H4...
       rewrite <- Permutation_midle...         
     + LLcopy F0.
       putFirst H2 (dual (F & G)).
       cutH Hi H2...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
   
   2:{ rewrite H2.
       LLbot (x++N).
       rewrite H in H0.
       cutH H0 Hj... }
       
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + solvell2.
     + checkPermutationCases H.
       rewrite H2.
       LLtop (M++x).
     + checkPermutationCases H.
       rewrite H3.
       LLleft F G (M++x).
       rewrite H in H1...
       putFirst H1 One.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLright F G (M++x).
       rewrite H in H1...
       putFirst H1 One.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLwith F G (M++x).
       rewrite H in H1.
       putFirst H1 One.
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 One.
       cutH Hi H2...
       rewrite <- Permutation_midle...          
     + checkPermutationCases H.
       rewrite H3.
       LLbot (M++x).
       rewrite H in H1...
       cutH Hi H1... exact Bot.
     + checkPermutationCases H.
       rewrite H3. 
       LLpar F G (M++x).
       rewrite H in H1.
       putFirst H1 One.
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...      
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LLtensor F G (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 One.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LLtensor F G M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 One.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LLstore F (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F::B; Bot :: M ->
            LL2 n0 |-- F::B; dual Bot::x ->
            LL2 |-- F::B; M++x).
       eapply CH...
       apply H2...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H5.
       LLexists t FX (M++x).
       rewrite H in H3.
       putFirst H3 One.
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLforall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 One.
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + LLcopy F.
       putFirst H1 (dual Bot).
       cutH Hi H1...
       rewrite <- Permutation_midle...
 
 
 
 * checkPermutationCases H.
   - inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
        rewrite H2.
        LLtop (M++x).
    + checkPermutationCases H.
        rewrite H4.
        LLleft F0 G0 (M++x).
        rewrite H in H1...
        putFirst H1 (dual F ⊗ dual G).
        cutH Hi H1...
       rewrite <- Permutation_midle...
    + checkPermutationCases H.
       rewrite H4.
       LLright F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (dual F ⊗ dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
    + checkPermutationCases H.
       rewrite H5.
       LLwith F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F ⊗ dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (dual F ⊗ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLbot (M++x).
       rewrite H in H1...
       cutH Hi H1...
     + checkPermutationCases H.
       rewrite H4. 
       LLpar F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (dual F ⊗ dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
   + checkPermutationCases H.
       inversion H5...
       rewrite H6.
       
       assert(LL2 n |-- B; F ::(G ::M) ->
              LL2 n0 |-- B; dual F :: M1 ->
              LL2 |-- B; (G ::M)++M1).
       eapply CW...
       simpl... 
       assert(LL2 |-- B; (G :: M) ++ M1).
       apply H...
       rewrite H3...
       apply LL2StoLL2N in H4...
       rewrite <- app_comm_cons in H4.
       cutW H4 H2...
       simpl...
       rewrite app_assoc. 
       apply WCUT...
       
       checkPermutationCases H.
       rewrite H5.
       rewrite <- H6.
       LLtensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (dual F ⊗ dual G).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H5.
       rewrite <- H6.
       LLtensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (dual F ⊗ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLstore F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F ⅋  G) :: M ->
            LL2 n0 |-- F0::B; dual (F ⅋  G)::x ->
            LL2 |-- F0::B; M++x).
       eapply CH... 
       apply H2...
       apply weakeningLL2N...
    + checkPermutationCases H.
       rewrite H6.
       LLexists t FX (M++x).
       rewrite H in H4.
       putFirst H4 (dual F ⊗ dual G).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLforall FX (M++x).
       apply H2 in H4.
       rewrite H in H4.
       putFirst H4 (dual F ⊗ dual G).
       cutH Hi H4...
       rewrite <- Permutation_midle...
      + LLcopy F0.
       putFirst H1 (dual (F ⅋ G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
   -  rewrite H2.
       LLpar F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj...
    * checkPermutationCases H. 
      inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
         rewrite H3.
         LLtop (M++x).
     + checkPermutationCases H.
       rewrite H5.
       LLleft F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (dual F ⅋ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLright F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (dual F ⅋ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LLwith F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (dual F ⅋ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       
       rewrite H in H3.
       putFirst H3 (dual F ⅋ dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...       
       + checkPermutationCases H.
       rewrite H5.
       LLbot (M++x).
       rewrite H in H2...
       cutH Hi H2...
      + checkPermutationCases H.
       inversion H5...
       rewrite H6.
       rewrite H4.
       
       assert(LL2 n |-- B; F :: M0 ->
            LL2 n0 |-- B; dual F::(dual G::M1) ->
            LL2 |-- B; M0++(dual G::M1)).
       eapply CW...
       simpl... 
       assert(LL2 |-- B; M0 ++ dual G :: M1).
       apply H...
       apply LL2StoLL2N in H3...
       rewrite <- Permutation_middle in H3.
       cutW H1 H3...
       simpl...
       rewrite (Permutation_app_comm M0).
       rewrite app_assoc_reverse.
       apply WCUT...
       
       rewrite H5.
       LLpar F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (dual F ⅋ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
            
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H6.
       rewrite <- H7.
       LLtensor F0 G0 (M++x0) N1;try solvell2.
       rewrite H in H2...
       putFirst H2 (dual F ⅋ dual G).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     
       rewrite H6.
       rewrite <- H7.
       LLtensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H3...
       putFirst H3 (dual F ⅋ dual G).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLstore F0 (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F0::B; (F ⊗ G) :: M ->
            LL2 n0 |-- F0::B; dual (F ⊗ G)::x ->
            LL2 |-- F0::B; M++x).
       eapply CH...
       apply H3...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H7.
       LLexists t FX (M++x).
       rewrite H in H5.
       putFirst H5 (dual F ⅋ dual G).
       cutH Hi H5...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LLforall FX (M++x).
       apply H3 in H5.
       rewrite H in H5.
       putFirst H5 (dual F ⅋ dual G).
       cutH Hi H5...
       rewrite <- Permutation_midle...
     + LLcopy F0.
       putFirst H2 (dual (F ⊗ G)).
       cutH Hi H2...
       rewrite <- Permutation_midle... 
    + checkPermutationCases H.
        rewrite H3.
        rewrite <- H4.
        LLtensor F G (N++x0) N0;try solvell2.
        rewrite H in H0.
        putFirst H0 C.
        cutH H0 Hj...
       rewrite Permutation_app_comm...
       rewrite H3.
       rewrite <- H4...
       LLtensor F G M0 (N++x0);try solvell2.
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj...
       rewrite Permutation_app_comm...
* checkPermutationCases H...
    +  rewrite <- H3 in H0.
   clear H3.
     assert(LL2 n |-- F::B; M ->
            LL2 j |-- B; dual (? F)::N ->
            LL2 |-- B; M++N).
     eapply CH... 
     apply H...
    +     
    rewrite H2.
       LLstore F (x++N).
       rewrite H in H0.
       apply @weakeningLL2N with (F:=F) in Hj.
       cutH H0 Hj... 
  
    * inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
         rewrite H1.
         LLtop x.
    + checkPermutationCases H.
       rewrite H3.
       LLleft F0 G x.
       rewrite H in H0...
       putFirst H0 (? dual F).
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H3.
       LLright F0 G x.
       rewrite H in H0...
       putFirst H0 (? dual F).
       cutH Hi H0...
    + checkPermutationCases H.
       rewrite H4.
       LLwith F0 G x.
       rewrite H in H0.
       putFirst H0 (? dual F).
       cutH Hi H0...
       rewrite H in H1.
       putFirst H1 (? dual F).
       cutH Hi H1...         
   + checkPermutationCases H.
       rewrite H3.
       LLbot x.
       rewrite H in H0...
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H3. 
       LLpar F0 G x.
       rewrite H in H0.
       putFirst H0 (? dual F).
       cutH Hi H0...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G x0 N0;try solvell2.
       rewrite H in H0...
       putFirst H0 (? dual F ).
       cutH Hi H0...
       
       rewrite H4.
       rewrite <- H5.
       LLtensor F0 G M x0;try solvell2.
       rewrite H in H1...
       putFirst H1 (? dual F).
       cutH Hi H1...
 
     + checkPermutationCases H.
        inversion H3...
       assert(LL2 n0 |-- dual F :: B; M ->
            LL2 S n |-- B; [! dual (dual F)] ->
            LL2 |-- B; M++[]).
       eapply CH...
       rewrite dualComplexity.
       simpl. rewrite <- dualInvolutive...
       rewrite H4...
       
       rewrite H3.
       LLstore F0 x.
       rewrite H in H0.
       eapply @weakeningLL2N with (F:=F0) in Hi. 
       cutH Hi H0...
       
     + checkPermutationCases H.
       rewrite H5.
       LLexists t FX x.
       rewrite H in H3.
       putFirst H3 (? dual F).
       cutH Hi H3...
     + checkPermutationCases H.
       rewrite H4.
       LLforall FX x.
       apply H1 in H3.
       rewrite H in H3.
       putFirst H3 (? dual F).
       cutH Hi H3...       
     + LLcopy F0.
       putFirst H0 (dual (! F)).
       cutH Hi H0...
 * checkPermutationCases H...
   2:{ rewrite H4.
       LLexists t FX (x++N).
       rewrite H in H2.
       putFirst H2 C.
       cutH H2 Hj... }
   rewrite <- H5 in H2.
   clear H5.   
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H4.
       LLtop (M++x).    
     + checkPermutationCases H.
       rewrite H5...
       LLleft F G (M++x).
       rewrite H in H3...
       putFirst H3 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5...
       LLright F G (M++x).
       rewrite H in H3...
       putFirst H3 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LLwith F G (M++x).
       rewrite H in H3.
       putFirst H3 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
       rewrite H in H4.
       putFirst H4 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLbot (M++x).
       rewrite H in H3...
       cutH Hi H3...
     + checkPermutationCases H.
       rewrite H5. 
       LLpar F G (M++x).
       rewrite H in H3.
       putFirst H3 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H6.
       rewrite <- H7.
       LLtensor F G (M++x0) N0;try solvell2.
       rewrite H in H3.
       putFirst H3 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
       rewrite H6.
       rewrite <- H7.
       LLtensor F G  M1 (M++x0);try solvell2.
       rewrite H in H4.
       putFirst H4 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H4...
       rewrite <- Permutation_midle...

     + checkPermutationCases H.
       rewrite H5.
       LLstore F (M++x).
       rewrite H in H3.
       assert(LL2 S n |-- F::B; ∃{ FX} :: M ->
            LL2 n0 |-- F::B; dual (∃{ FX}) ::x ->
            LL2 |-- F::B; M++x).
       eapply CH...
       apply H4...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H7.
       LLexists t0 FX0 (M++x).
       rewrite H in H5.
       putFirst H5 (∀{ fun x : expr con => dual (FX x) }).
       cutH Hi H5...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H6...
       assert(proper t) by auto.
       specialize (H4 _ H1).
       cutW H2 H4...
       simpl...
       assert(proper (VAR con 0%nat)).
       apply proper_VAR.
       eapply @ComplexityUniformEq with (FX:=FX) (x:=t) in H1...
       rewrite H7... 
       
       rewrite H6.
       LLforall FX0 (M++x).
       specialize (H4 _ H5).
       rewrite H in H4.
       putFirst H4 (∀{ fun x : expr con => dual (FX x)}).
       cutH Hi H4...
       rewrite <- Permutation_midle...       
    + LLcopy F.
       putFirst H3 (dual (∃{ FX})).
       cutH Hi H3...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
   2:{ rewrite H3.
       LLforall FX (x++N).
       specialize (H1 _ H2).
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj... }
   assert(Hn1 : forall x : expr con,
     proper x -> LL2 n |-- B; FX x :: M).    
   intros.
   specialize (H1 _ H).     
   rewrite H4...
   clear H4 H1.
   rename Hn1 into H1.   
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       rewrite H3.
       LLtop (M++x).
     + checkPermutationCases H.
       rewrite H4...
       LLleft F G (M++x).
       rewrite H in H2...
       putFirst H2 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4...
       LLright F G (M++x).
       rewrite H in H2...
       putFirst H2 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLwith F G (M++x).
       rewrite H in H2.
       putFirst H2 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H in H3.
       putFirst H3 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle... 
    + checkPermutationCases H.
       rewrite H4.
       LLbot (M++x).
       rewrite H in H2...
       cutH Hi H2... exact Bot.        
     + checkPermutationCases H.
       rewrite H4. 
       LLpar F G (M++x).
       rewrite H in H2.
       putFirst H2 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle... 
    + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H5.
       rewrite <- H6.
       LLtensor F G (M++x0) N0;try solvell2.
       rewrite H in H2.
       putFirst H2 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H5.
       rewrite <- H6.
       LLtensor F G  M1 (M++x0);try solvell2.
       rewrite H in H3.
       putFirst H3 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LLstore F (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F::B; ∀{ FX} :: M ->
            LL2 n0 |-- F::B; dual (∀{ FX}) ::x ->
            LL2 |-- F::B; M++x).
       eapply CH...
       apply H3...
       apply weakeningLL2N...
     + checkPermutationCases H.
       rewrite H7.
       inversion H6...
       assert(proper t) by auto.
       specialize (H1 _ H3). 
       cutW H1 H4...
       simpl...
       assert(proper (VAR con 0%nat)).
       apply proper_VAR.
       eapply @ComplexityUniformEq with (FX:=FX) (x:=t) in H3...
       
       rewrite H6.
       LLexists t FX0 (M++x).
       rewrite H in H4.
       putFirst H4 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LLforall FX0 (M++x).
       specialize (H3 _ H4).
       rewrite H in H3.
       putFirst H3 (∃{ fun x : expr con => dual (FX x)}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + LLcopy F.
       putFirst H2 (dual (∀{ FX})).
       cutH Hi H2...
       rewrite <- Permutation_midle...       
       
    *  LLcopy F. 
       putFirst H0 C.
       cutH H0 Hj...
Qed. 

End CutLElimination.
