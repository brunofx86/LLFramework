(** Cut Elimination for Focused Linear Logic

This file proves cut-elimination for the triadic system of linear
logic. The proof uses 5 cut-rules dealing with the negative and
positive phase of proofs (see [CutElimBase]).

It is assumed that the theory only produces well formed LL formulas
(see [TheoryIsFormula]).
 *)


Require Export LL.Misc.Hybrid.
Require Export LL.Framework.SL.SELLF.Tactics.
Require Import Lia.
Require Import LL.Misc.Permutations.
Require Import FunInd.
Require Import Coq.Program.Equality.
Require Export LL.Framework.SL.SELLF.InvPositivePhase.
Require Export LL.Framework.SL.SELLF.Reasoning.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section CutElimination.
  Context `{OLS: OLSig}.
Context `{SI : SigSELL}.
  Variable th : oo -> Prop.
  
  Theorem CutAtom {SIU: USigSELL} B M N L C:
  SELLS th B M (UP (atom C::L)) -> SELLS th B N (DW (perp C))  ->
  SELLS th B (M++N) (UP L).
  Proof with sauto;try solveLL.
  intros Hd1 Hd2.
  inversion Hd2...
  inversion Hd1...
  LLExact H5.
  rewrite <- H3.
  apply AbsorptionC'... 
  rewrite H3.
  inversion Hd1...
  inversion H0.
  Qed.
  
    Definition CutW (w: nat) :=  
    forall i j cF A P M N L B C D, 
    complexity cF < w -> SetU B -> SetL C -> SetL D ->
      (SELLN th i (B++C) (cF::M) (UP L) -> SELLN th j (B++D) N (UP [dual cF]) -> SELLS th (B++C++D) (M ++ N) (UP L)) /\
      (SELLN th i (B++C) M (UP (cF :: L)) -> SELLN th j (B++D) N (DW (dual cF)) -> SELLS th (B++C++D) (M ++ N) (UP L)) /\
       (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (DW P) -> SELLN th j (B++D) [] (DW (Bang a (dual A))) -> SELLS th (B++C++D) M (UP [P]))  /\
      (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (UP L) -> SELLN th j (B++D) [] (DW (Bang a (dual A))) -> SELLS th (B++C++D) M (UP L)). 
    
  Definition CutH (w h: nat) :=  
    forall i j cF A P M N L B C D, 
    i + j < h ->
    complexity cF = w -> SetU B -> SetL C -> SetL D ->
      (SELLN th i (B++C) (cF::M) (UP L) -> SELLN th j (B++D) N (UP [dual cF]) -> SELLS th (B++C++D) (M ++ N) (UP L)) /\
      (SELLN th i (B++C) M (UP (cF :: L)) -> SELLN th j (B++D) N (DW (dual cF)) -> SELLS th (B++C++D) (M ++ N) (UP L)) /\
      (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (DW P) -> SELLN th j (B++D) [] (DW (Bang a (dual A))) -> SELLS th (B++C++D) M (UP [P]))   /\
      (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (UP L) -> SELLN th j (B++D) [] (DW (Bang a (dual A))) -> SELLS th (B++C++D) M (UP L)). 
          
Ltac applyCutH := 
  match goal with
  | [ H: CutH _ _ |- 
         SELLN ?th ?x _ _ _ -> 
         SELLN ?th ?y _ _ _ -> 
         SELLS ?th _ _ _ ] => eapply H
  | _ => idtac end;sauto.
  
Ltac applyCutW := 
  match goal with
  | [ H: CutW _ |- 
         SELLN ?th ?x _ _ _ -> 
         SELLN ?th ?y _ _ _ -> 
         SELLS ?th _ _ _ ] => eapply H
  | _ => idtac end;sauto.

Ltac cut1H P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 (?B++?C) (?FC::?M) (UP ?L) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) ?N (UP [dual ?FC]) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) (M++N) (UP L));applyCutH
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut2H P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 (?B++?C) ?M (UP (?FC::?L)) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) ?N (DW (dual ?FC)) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) (M++N) (UP L));applyCutH
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut3H P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 ((?e, ?FC)::(?B++?C)) ?M (DW ?P) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) [] (DW (Bang ?e (dual ?FC))) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) M (UP [P]));applyCutH
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut4H P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 ((?e, ?FC)::(?B++?C)) ?M (UP ?L) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) [] (DW (Bang ?e (dual ?FC))) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) M (UP L));applyCutH
           | _ => idtac "type of " P2 " is " tP2 end
   | _ => idtac "type of " P1 " is " tP1 end;sauto.

Ltac cut1W P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 (?B++?C) (?FC::?M) (UP ?L) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) ?N (UP [dual ?FC]) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) (M++N) (UP L));applyCutW
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut2W P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 (?B++?C) ?M (UP (?FC::?L)) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) ?N (DW (dual ?FC)) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) (M++N) (UP L));applyCutW
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut3W P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 ((?e, ?FC)::(?B++?C)) ?M (DW ?P) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) [] (DW (Bang ?e (dual ?FC))) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) M (UP [P]));applyCutW
           | _ => idtac "type of " P2 " is " tP2 end
end.

Ltac cut4W P1 P2 :=
   let tP1 := type of P1 in
   let tP2 := type of P2 in
   let H' := fresh "OLCut" in
   match tP1 with
   | SELLN ?th ?h1 ((?e, ?FC)::(?B++?C)) ?M (UP ?L) => 
          match tP2 with 
          | SELLN ?th ?h2 (?B++?D) [] (DW (Bang ?e (dual ?FC))) =>  
                      assert(H': tP1 -> tP2 -> SELLS th (B++C++D) M (UP L));applyCutW
           | _ => idtac "type of " P2 " is " tP2 end
   | _ => idtac "type of " P1 " is " tP1 end;sauto.

Lemma unformUnb B C X Y Z : 
    SetU B -> SetL C -> SetU X -> SetL Y -> SetL Z -> 
    Permutation (B ++ C) (X ++ Y ++ Z) -> Permutation B X /\ Permutation C (Y++Z).
Proof with sauto.
  revert C X Y Z.
  induction B;intros. 
  - destruct X...
    +  rewrite H4 in H0.
        rewrite <- app_comm_cons in H0. 
        inversion H1. inversion H0...
    +  rewrite H4 in H0.
        rewrite <- app_comm_cons in H0. 
        inversion H1. inversion H0...
  - rewrite <- app_comm_cons in H4. 
    checkPermutationCases H4.
    rewrite H4. apply perm_skip.
    rewrite H4 in H1. 
    inversion H...
    inversion H1...
    pose proof (IHB C x Y Z H9 H0 H11 H2 H3 (symmetry H6))...
    rewrite H4 in H1. 
    inversion H...
    inversion H1...
    pose proof (IHB C x Y Z H9 H0 H11 H2 H3 (symmetry H6))...
    inversion H... 
    checkPermutationCases H4.
    rewrite H4 in H2. inversion H2...
    rewrite H4 in H3. inversion H3...
    inversion H... 
    checkPermutationCases H4.
    rewrite H4 in H2. inversion H2...
    rewrite H4 in H3. inversion H3...
Qed.


Theorem Cut1  a b P L M N B C D: 
CutH (complexity P) (a+b) -> SetU B -> SetL C -> SetL D ->
  SELLN th a (B++C) (P::M) (UP L) ->
  SELLN th b (B++D) N (UP [P ^]) ->
  SELLS th (B++C++D) (M ++ N) (UP L ).
Proof with sauto;try solveLL.  
 intros CH stB stC stD Ha Hb.
 inversion Ha...
 * cut1H H0 Hb.
 * cut1H H4 Hb.
 * cut1H H3 Hb. 
 * cut1H H3 Hb. 
 * destruct (uDec i). 
    - apply weakeningN with (F:=(i,F)) in Hb.
      rewrite !app_comm_cons in H3, Hb.
      cut1H H3 Hb. simpl...
    - rewrite Permutation_middle in H3.
      rewrite Permutation_middle.
      cut1H H3 Hb.
 * apply H4 in properX...
    cut1H properX Hb.

 * rewrite perm_swap in H4. 
    cut1H H4 Hb. 
 * checkPermutationCases H1.
    -  rewrite H3 in H5. 
       rewrite (dualInvolutive P) in H5...
       LLPerm(N ++ M).
       cut2H Hb H5.
      LLPerm(B++D++C)... 
    - rewrite H2 in H5. clear H2.
       inversion H5...
       + inversion Hb...
          LLPerm((B++D)++C).
         apply weakeningGen_rev...
         HProof.
        apply Forall_app in H4...
       +  destruct(posOrNeg F0).   
       { rewrite H1. 
                 rewrite <- app_comm_cons. 
                 apply InvPlus...
                 LLStore.
                assert( SELLN th (S n0) (B++C) (P::(F0::x)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++C++D) ((F0::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
                rewrite app_comm_cons...
                apply Cut...
                LFocus F0 (P::x). 
             
 }

             {   inversion H6;CleanContext...  
                 rewrite H1.
                 rewrite <- app_comm_cons. 
                 apply InvPlus...
                 cut1H H9 Hb. 
               }
 
  +    destruct(posOrNeg G).   
       {         rewrite H1.
                 rewrite <- app_comm_cons. 
                 apply InvPlusComm...
                 LLStore. 
                assert(SELLN th (S n0) (B++C) (P::(G::x)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++C++D) ((G::x ) ++ N) (UP [ ])) as Cut.
                eapply CH...
                rewrite app_comm_cons...
                apply Cut...
                 LFocus G (P::x).  }

             {   inversion H6;CleanContext...  
                 rewrite H1.
                 rewrite <- app_comm_cons. 
                 apply InvPlusComm...
                 cut1H H9 Hb.   
               }
+           checkPermutationCases H2.
    {   pose proof (unformUnb  stB stC H4 H6 H7 H3)...
              destruct(posOrNeg F0).
              * (* first *) 
                assert(SELLN th (S n0) (B++C0) (P::(F0::x0)) (UP [])).
              LFocus F0 (P::x0)...
              HProof. 
              rewrite H10...
              cut1H H13 Hb. 
               
              rewrite H1. rewrite H11.
              rewrite <- app_comm_cons.
              apply TensorComm'.
              rewrite <- H9.
              LLPerm(G ⊗ F0::N0++(x0++N)).
              LLPerm (B ++ D0 ++ (C0 ++ D)).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app...
              apply unRelease.
              rewrite H10.
              HProof.
             * (* second *) 
            inversion H8;CleanContext...
              rewrite H1.
              rewrite <- app_comm_cons.
              apply TensorComm'.
              rewrite <- H9.
              LLPerm(G ⊗ F0::N0++(x0++N)).
             rewrite H11. 
             LLPerm (B ++ D0 ++ (C0 ++ D)).
                rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app... rewrite H10.
                apply unRelease.
              HProof.
                 rewrite <- H10 in H18.
                rewrite H2 in H18.
                 cut1H H18 Hb. }
  {   pose proof (unformUnb  stB stC H4 H6 H7 H3)...
              destruct(posOrNeg G).
              * (* first *) 
                assert(SELLN th (S n0) (B++D0) (P::(G::x0)) (UP [])).
              LFocus G (P::x0)...
              HProof. 
              rewrite H10...
              cut1H H13 Hb. 
               
              rewrite H1. rewrite H11.
              rewrite <- app_comm_cons.
              rewrite <- H9.
              LLPerm(F0⊗ G::M0++(x0++N)).
              LLPerm (B ++ C0 ++ (D0 ++ D)).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app...
              apply unRelease.
              rewrite H10.
              HProof.
             * (* second *) 
            inversion H12;CleanContext...
              rewrite H1.
              rewrite <- app_comm_cons.
              rewrite <- H9.
LLPerm(F0⊗ G::M0++(x0++N)).
              rewrite H11. 
             LLPerm (B ++ C0 ++ (D0 ++ D)).
                rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app... rewrite H10.
                apply unRelease.
              HProof.
                 rewrite <- H10 in H18.
                rewrite H2 in H18.
                 cut1H H18 Hb. }
   +   destruct(posOrNeg (FX t)).   
       { rewrite H1. 
                 rewrite <- app_comm_cons. 
                 apply @InvEx with (t:=t)...
                 LLStore. 
                 assert( SELLN th (S n0) (B++C) (P::(FX t::x) ) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++C++D) ((FX t::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
                rewrite app_comm_cons...
                apply Cut...
                 LFocus (FX t) (P::x).  }
             {   inversion H8;subst;auto;
               try match goal with 
               [ H1: _ = FX t, H2: negFormula (FX t) |- _] => rewrite <- H1 in H2;inversion H2
                end. 
                 rewrite H1.
                 rewrite <- app_comm_cons. 
                 apply @InvEx with (t:=t)...
                 cut1H H11 Hb.  }
       +  apply posNotNeg in H0. contradiction. 
           
*  assert (In (i,F) B).
    apply in_app_or in H2... 
    pose proof (SETUNotIn i F C H0 stC H)...
    clear H2. 
  destruct(posOrNeg F).
- inversion H6...
       + apply Forall_app in H7... 
          pose proof (SETXempty C H4 stC)... 
apply @AbsorptionClassic' with (i:=i)  (F:=perp A)...
          inversion Hb...
          HProof.
  +  destruct(posOrNeg F0).   
     {  eapply @InvPlusC with (F:=F0) (G:=G) (i:=i)...
        rewrite <- (app_nil_l [F0]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(F0::M) ) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((F0::M) ++ N) (UP [ ])) as Cut.
                eapply CH... 
               LLPerm( (F0::M) ++ N)...
               apply Cut...
               LFocus F0 (P::M). }
                
     {  inversion H8;CleanContext...               
        eapply @InvPlusC with (F:=F0) (G:=G) (i:=i)...
                 cut1H H11 Hb. 
}
  +  destruct(posOrNeg G).   
     {  eapply @InvPlusCComm with (F:=F0) (G:=G) (i:=i)...
        rewrite <- (app_nil_l [G]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(G::M) ) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((G::M) ++ N) (UP [ ])) as Cut.
                eapply CH... 
               LLPerm( (G::M) ++ N)...
               apply Cut...
               LFocus G (P::M).  }
                
     {  inversion H8;CleanContext...               
        eapply @InvPlusCComm with (F:=F0) (G:=G) (i:=i)...
                 cut1H H11 Hb.  }

      + pose proof (unformUnb  stB stC H7 H8 H9 H5)...
        checkPermutationCases H4.
          {  destruct(posOrNeg F0).
             * (* first *) 
               rewrite <- H13.
               rewrite H12.
               LLPerm((x ++ N) ++ N0).
              LLPerm(B ++ (C0++D)++D0).
               rewrite <- (app_nil_r []).
               eapply @InvTensorC with (F:=F0) (G:=G) (i:=i)...
              apply Forall_app...
               rewrite <- (app_nil_l [F0]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B++C0) (P::(F0::x)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++C0++D) ((F0::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((F0 :: x) ++ N)...
              apply Cut...
               LFocus F0 (P::x). HProof. 
              1-2: rewrite H11... 
               apply unRelease.
               HProof.  
       * inversion H10;CleanContext...
               rewrite <- H13.
               rewrite H12.
               LLPerm((x ++ N) ++ N0).
              LLPerm(B ++ (C0++D)++D0).
               rewrite <- (app_nil_r []).
               eapply @InvTensorC with (F:=F0) (G:=G) (i:=i)...
              apply Forall_app...
                 rewrite  H4 in H20.
               rewrite <- H11 in H20.
                 cut1H H20 Hb. 

               apply unRelease.
               rewrite H11.
                HProof.
              } 
          {  destruct(posOrNeg G).
             * (* first *) 
               rewrite <- H13.
               rewrite H12.
               LLPerm(M0++(x ++ N)).
              LLPerm(B ++ C0++(D0++D)).
               rewrite <- (app_nil_r []).
               eapply @InvTensorC with (F:=F0) (G:=G) (i:=i)...
              apply Forall_app...
              apply unRelease.
              rewrite H11...
              HProof.
               rewrite <- (app_nil_l [G]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B++D0) (P::(G::x)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++D0++D) ((G::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((G :: x) ++ N)...
              apply Cut...
               LFocus G (P::x). HProof. rewrite H11... 
       * inversion H14;CleanContext...
               rewrite <- H13.
               rewrite H12.
               LLPerm(M0++(x ++ N) ).
              LLPerm(B ++ C0++(D0++D)).
               rewrite <- (app_nil_r []).
               eapply @InvTensorC with (F:=F0) (G:=G) (i:=i)...
              apply Forall_app...
               apply unRelease.
               rewrite H11.
                HProof.
     rewrite  H4 in H20.
               rewrite <- H11 in H20.
                 cut1H H20 Hb. } 
  +  destruct(posOrNeg (FX t)).   
     { eapply @InvExC with  (t:=t) (FX:=FX) (i:=i)...
        rewrite <- (app_nil_l [FX t]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(FX t::M)) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((FX t::M) ++ N) (UP [ ])) as Cut.
                eapply CH...
        LLPerm((FX t :: M) ++ N)...
        apply Cut... 
        LFocus (FX t) (P::M).  }
     {  inversion H10;subst;auto;
               try match goal with 
               [ H1: _ = FX t, H2: negFormula (FX t) |- _] => rewrite <- H1 in H2;inversion H2
                end.             
        eapply @InvExC with (t:=t) (FX:=FX) (i:=i)...
                 cut1H H13 Hb. 
}
    +  apply posNotNeg in H2. contradiction. 
 -  inversion H6;CleanContext... 
       apply @AbsorptionClassic' with (F:=F) (i:=i)...
        cut1H H9 Hb. 
*
  checkPermutationCases H2.
  rewrite H2 in stB.
  inversion stB...
  assert(stX: SetL x).
 rewrite H2 in stC. inversion stC... 
 destruct(posOrNeg F).
- inversion H6...
       +  
          rewrite H2. 
          LLPerm ( (i, perp A) :: x ++ (B ++ D)).
          apply AbsorptionL'...
          inversion Hb...
          apply weakeningGen... rewrite <- H3 in H8. apply Forall_app in H8...
          HProof.
  +  destruct(posOrNeg F0).   
     {  eapply @InvPlusL with (F:=F0) (G:=G) (i:=i) (B':=B++x++D)...
        rewrite H2...
        rewrite <- (app_nil_l [F0]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++x) (P::(F0::M) ) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++x++D) ((F0::M) ++ N) (UP [ ])) as Cut.
                eapply CH...
               rewrite H2 in stC. inversion stC... 
               LLPerm( (F0::M) ++ N)...
               apply Cut...
               LFocus F0 (P::M). rewrite H3... }
                
     {  inversion H9;CleanContext...               
        eapply @InvPlusL with (F:=F0) (G:=G) (i:=i) (B':=B++x++D)...
          rewrite H2...    
          rewrite <- H3 in H12.
         cut1H H12 Hb. 
}
  +  destruct(posOrNeg G).   
     {  eapply @InvPlusLComm with (F:=F0) (G:=G) (i:=i) (B':=B++x++D)...
         rewrite H2...
        rewrite <- (app_nil_l [G]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++x) (P::(G::M) ) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++x++D) ((G::M) ++ N) (UP [ ])) as Cut.
                eapply CH...
               rewrite H2 in stC. inversion stC... 
               LLPerm( (G::M) ++ N)...
               apply Cut...
               LFocus G (P::M). rewrite H3...  }
                
     {  inversion H9;CleanContext...               
        eapply @InvPlusLComm with (F:=F0) (G:=G) (i:=i)  (B':=B++x++D)...
            rewrite H2... 
       rewrite <- H3 in H12.    cut1H H12 Hb. }

      + rewrite <- H3 in H7. 
pose proof (unformUnb  stB stX H8 H9 H10 H7)...
        checkPermutationCases H5.
          {  destruct(posOrNeg F0).
             * (* first *) 
               rewrite <- H14.
               rewrite H12.
               LLPerm((x0 ++ N) ++ N0).
                rewrite H2, H13.
                LLPerm (B0 ++ ((i, F0 ⊗ G) :: C0 ++ D) ++ D0).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorL1 with (F:=F0) (G:=G) (i:=i) (C':=C0 ++ D)...
               apply Forall_cons...
               apply Forall_app...
                 rewrite <- (app_nil_l [F0]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B++C0) (P::(F0::x0)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++C0++D) ((F0::x0) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((F0 :: x0) ++ N)... rewrite <- H12...
              apply Cut...
               LFocus F0 (P::x0). HProof. 
              rewrite H12...
               apply unRelease.
               HProof.  
       * inversion H11;CleanContext...
               rewrite <- H14.
               rewrite H12.
               LLPerm((x0 ++ N) ++ N0).
rewrite H2, H13.
                LLPerm (B0 ++ ((i, F0 ⊗ G) :: C0 ++ D) ++ D0).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorL1 with (F:=F0) (G:=G) (i:=i) (C':=C0 ++ D)...
               apply Forall_cons...
               apply Forall_app...
                 rewrite  H12 in Hb.
                rewrite H5 in H21.
                 cut1H H21 Hb. 

               apply unRelease.
                HProof.
              } 
          {  destruct(posOrNeg G).
             * (* first *) 
               rewrite <- H14.
               rewrite H12.
               LLPerm(M0++(x0 ++ N) ).
                rewrite H2, H13.
                LLPerm (B0 ++ C0++((i, F0 ⊗ G) :: D0 ++ D)).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorL2 with (F:=F0) (G:=G) (i:=i) (D':=D0 ++ D)...
               apply Forall_cons...
               apply Forall_app...
               apply unRelease.
               HProof.  
                 rewrite <- (app_nil_l [G]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B++D0) (P::(G::x0)) (UP [ ]) ->
                       SELLN th b (B++D) N (UP [dual P]) ->
                         SELLS th (B++D0++D) ((G::x0) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((G :: x0) ++ N)... rewrite <- H12...
              apply Cut...
               LFocus G (P::x0). HProof. 
              rewrite H12...
       * inversion H15;CleanContext...
               rewrite <- H14.
               rewrite H12.
               LLPerm(M0++(x0 ++ N)).
rewrite H2, H13.
                LLPerm (B0 ++ C0++((i, F0 ⊗ G) :: D0 ++ D) ).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorL2 with (F:=F0) (G:=G) (i:=i) (D':=D0 ++ D)...
               apply Forall_cons...
               apply Forall_app...
               apply unRelease.
                HProof.
                 rewrite  H12 in Hb.
                rewrite H5 in H21.
                 cut1H H21 Hb. } 
 
  +  destruct(posOrNeg (FX t)).   
     { eapply @InvExL with  (t:=t) (FX:=FX) (i:=i) (B':=B++x++D)...
        rewrite H2...
        rewrite <- (app_nil_l [FX t]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++x) (P::(FX t::M)) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++x++D) ((FX t::M) ++ N) (UP [ ])) as Cut.
                eapply CH...
        LLPerm((FX t :: M) ++ N)...
        apply Cut... 
        LFocus (FX t) (P::M). rewrite H3...  }
     {  inversion H11;subst;auto;
               try match goal with 
               [ H1: _ = FX t, H2: negFormula (FX t) |- _] => rewrite <- H1 in H2;inversion H2
                end.             
        eapply @InvExL with (t:=t) (FX:=FX) (i:=i) (B':=B++x++D)...
        rewrite H2...
         rewrite <- H3 in H14.
                 cut1H H14 Hb. 
}
    +  apply posNotNeg in H. contradiction. 
 -  inversion H6;CleanContext...
    rewrite H2.
     LLPerm ( (i, F) :: x ++ (B ++ D)).
       apply @AbsorptionLinear with (F:=F) (i:=i) (B':=x++B++D)...
         rewrite <- H3 in H10.
                 cut1H H10 Hb. 
        LLPerm (B++x++D)...
*  inversion H5...
    + apply Forall_app in H4...
         pose proof (SETXempty C H2 stC)... 
    eapply @AbsorptionPerp' with (A:=A)...
        inversion Hb...
        HProof.
  + destruct(posOrNeg F0).   
     {  eapply @InvPlusT with (F:=F0) (G:=G)...
        rewrite <- (app_nil_l [F0]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(F0::M)) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((F0::M) ++ N) (UP [ ])) as Cut.
                eapply CH... 
               LLPerm( (F0::M) ++ N)...
               apply Cut...
               LFocus F0 (P::M). }
                
     {  inversion H6;CleanContext...               
        eapply @InvPlusT with (F:=F0) (G:=G) ...
                 cut1H H9 Hb. 
}
  +  destruct(posOrNeg G).   
     {  eapply @InvPlusTComm with (F:=F0) (G:=G)...
        rewrite <- (app_nil_l [G]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(G::M)) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((G::M) ++ N) (UP [ ])) as Cut.
                eapply CH... 
               LLPerm( (G::M) ++ N)...
               apply Cut...
               LFocus G (P::M).  }
                
     {  inversion H6;CleanContext...               
        eapply @InvPlusTComm with (F:=F0) (G:=G)...
                 cut1H H9 Hb. 
 }

      + 
pose proof (unformUnb  stB stC H4 H6 H7 H3)...
        checkPermutationCases H2.
          {  destruct(posOrNeg F0).
             * (* first *) 
               rewrite <- H11.
               rewrite H9.
               LLPerm((x ++ N) ++ N0).
              rewrite H10.
                LLPerm (B0 ++  (C0 ++ D) ++ D0).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorT with (F:=F0) (G:=G)...
               apply Forall_app...
                 rewrite <- (app_nil_l [F0]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B0++C0) (P::(F0::x)) (UP [ ]) ->
                       SELLN th b (B0++D) N (UP [dual P]) ->
                         SELLS th (B0++C0++D) ((F0::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((F0 :: x) ++ N)... 
              apply Cut...
               LFocus F0 (P::x). HProof. 
              rewrite <- H9...
               apply unRelease.
               HProof.  
       * inversion H8;CleanContext...
               rewrite <- H11.
               rewrite H9.
               LLPerm((x ++ N) ++ N0).
rewrite H10.
                LLPerm (B0 ++ (C0 ++ D) ++ D0).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorT with (F:=F0) (G:=G)...
               apply Forall_app...
                 rewrite  H9 in Hb.
                rewrite H2 in H18.
                 cut1H H18 Hb. 

               apply unRelease.
                HProof.
              } 
          {  destruct(posOrNeg G).
             * (* first *) 
               rewrite <- H11.
               rewrite H10.
               LLPerm(M0++(x ++ N) ).
                rewrite H9.
                LLPerm (B0 ++ C0++(D0 ++ D)).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorT with (F:=F0) (G:=G)...
               apply Forall_app...
               apply unRelease.
               HProof.  
                 rewrite <- (app_nil_l [G]).
               apply UpExtension'...
                
                 assert(SELLN th (S n0) (B0++D0) (P::(G::x)) (UP [ ]) ->
                       SELLN th b (B0++D) N (UP [dual P]) ->
                         SELLS th (B0++D0++D) ((G::x) ++ N) (UP [ ])) as Cut.
                eapply CH...
               LLPerm((G :: x) ++ N)... 
              apply Cut...
               LFocus G (P::x). HProof. 
              rewrite <- H9...
       * inversion H12;CleanContext...
               rewrite <- H11.
               rewrite H9, H10.
               LLPerm(M0++(x ++ N)).
                LLPerm (B0 ++ C0++(D0 ++ D) ).
                 rewrite <- (app_nil_r []).
            
               eapply @InvTensorT with (F:=F0) (G:=G)...
               apply Forall_app...
               apply unRelease.
                HProof.
                 rewrite  H9 in Hb.
                rewrite H2 in H18.
                 cut1H H18 Hb. } 

  +  destruct(posOrNeg (FX t)).   
     {  eapply @InvExT with  (t:=t) (FX:=FX)...
        rewrite <- (app_nil_l [FX t]).
        apply UpExtension'...
        assert(SELLN th (S n0) (B++C) (P::(FX t::M)) (UP [ ]) ->
                  SELLN th b (B++D) N (UP [dual P]) ->
                    SELLS th (B++C++D) ((FX t::M) ++ N) (UP [ ])) as Cut.
                eapply CH...
       apply Cut...
       LFocus (FX t) (P::M). }
          {  inversion H8;subst;auto;
               try match goal with 
               [ H1: _ = FX t, H2: negFormula (FX t) |- _] => rewrite <- H1 in H2;inversion H2
                end.             
        eapply @InvExT with (t:=t) (FX:=FX)...
                 cut1H H11 Hb. 
}
                
  + TFocus F. apply tri_rel'... 
                 cut1H H7 Hb.

Qed.
  
  Theorem Cut2  a b P L M N B C D : 
  CutH (complexity P) (a+b) -> CutW (complexity P) -> SetU B -> SetL C -> SetL D ->
  SELLN th a (B++C) M (UP (P::L)) ->
  SELLN th b (B++D) N (DW (dual P)) ->
  SELLS th (B++C++D) (M ++ N) (UP L).
Proof with sauto;try solveLL.   
 intros CH CW stB stC stD Ha Hb.
 inversion Ha;subst. 
 * inversion Hb...
   CleanContext.
 * inversion Hb; CleanContext...
   cut2W H4 H3.
   simpl...
   cut2W H5 H3.
   simpl...
 * inversion Hb; CleanContext...
   apply Forall_app in H...
   pose proof (SETXempty D H1 stD)...  
    HProof.
 * inversion Hb; CleanContext...
    pose proof (unformUnb  stB stD H4 H5 H6 H2)...
     rewrite H0 in H3.    
    cut2W H3 H10.
    simpl...
   apply OLCut in H10;auto.
    apply seqtoSeqN in H10...
    cut2W H10 H11.
    simpl... apply Forall_app...
    rewrite H0, H7, H1.
    LLPerm((M ++ M0) ++ N0)...
    LLPerm(B0 ++ (C ++ C0) ++ D0)...
 *  assert(N=[]). inversion Hb; try solvePolarity. 
    inversion H0...
   subst.
   simpl in Hb.
   cut4H H3 Hb.
  * inversion Hb;CleanContext...
     pose proof (H5 _ H1).
    cut2W H H7. 

   simpl...
    remember (VAR con 0%nat).
            assert(proper e).
            rewrite Heqe.  
            constructor.
            subst.
            erewrite ComplexityUniformEq...
          
 *  apply posLDestruct in H4...
   assert(negFormula (P ^)).
   apply posDualNeg in H...
 
     inversion Hb;subst; try match goal with
       [ H: _= dual ?C , H2: negFormula (dual ?C) |- _ ] => rewrite <- H in H2
     end;CleanContext.
    cut1H H5 H7.
   inversion H...
   inversion Hb...
   apply Forall_app in H4...
   pose proof (SETXempty D H1 stD)...  
   HProof.
   inversion Ha...
   destruct (uDec i).
   checkPermutationCases H6.
  rewrite <- H3 in H1.   apply Forall_app in H1...
   pose proof (SETXempty D H4 stD)...  
  
rewrite H2. rewrite <- app_comm_cons...

   eapply AbsorptionC'...
rewrite  app_comm_cons...
    rewrite <- H2. HProof.
   rewrite H2 in stD. inversion stD...

   checkPermutationCases H6.
   rewrite H2 in stB. inversion stB...
  rewrite <- H3 in H1. 
   rewrite H2 in stD.  apply Forall_app in H1...
   inversion stD...
   pose proof (SETXempty x H4 H7)...  
  LLPerm ((i, atom A) :: B++C).
   eapply AbsorptionL'...
HProof.
   solvePolarity. 
 Qed.
 
Lemma weakeningSet
     : forall (theory : oo -> Prop) (CC : list location) 
        c (LC : list oo) (X : Arrow),
       LtX c (getL CC) -> SELLS theory (getLtX c CC)  LC X -> SELLS theory CC LC X.
Proof with sauto.
  intros.
  rewrite (cxtDestructNoLtX c CC).
  apply weakeningGen_rev...
  apply cxtDestructNoLtX'...
Qed.

Lemma weakeningSetN n
     : forall (theory : oo -> Prop) (CC : list location) 
        c (LC : list oo) (X : Arrow),
       LtX c (getL CC) -> SELLN theory n  (getLtX c CC)  LC X -> SELLN theory n CC LC X.
Proof with sauto.
  intros.
  rewrite (cxtDestructNoLtX c CC).
  apply weakeningGenN_rev...
  apply cxtDestructNoLtX'...
Qed.

Lemma confBang c B C: SetL C -> LtX c (getL C) -> getLtX c (B ++ C) = getLtX c B ++ C.
Proof with sauto.
  intros.
  rewrite getLtXApp.
  enough (getLtX c C = C)...
  rewrite H1...
   induction C...
  destruct a as [a F].
simpl in *...
 simpl in H0.
  inversion H...
 inversion H0...
destruct (lt_dec c a)...
  apply IHC in H6... rewrite H6...
Qed.

Lemma SetULPerm B1 B2 C1 C2: 
  SetU B1 -> SetU B2 -> SetL C1 -> SetL C2 -> Permutation (B1 ++ C1) (B2 ++ C2) -> Permutation B1 B2 /\ Permutation C1 C2.
Proof with sauto.
  revert B2 C1 C2. induction B1;intros. 
 - destruct B2...
    rewrite H3 in H1. rewrite <- app_comm_cons in H1. 
    inversion H1...
    inversion H0...
    rewrite H3 in H1. rewrite <- app_comm_cons in H1. 
    inversion H1...
    inversion H0...
 - destruct B2...
    rewrite <- H3 in H2. rewrite <- app_comm_cons in H2. 
    inversion H2...
    inversion H...
    rewrite <- H3 in H2. rewrite <- app_comm_cons in H2. 
    inversion H2...
    inversion H...
   { checkPermutationCases H3.
     inversion H... inversion H0...
     pose proof (IHB1 B2 C1 C2 H7 H9 H1 H2 H6)...
     checkPermutationCases H3. 
     rewrite H3.
     rewrite perm_swap.
     rewrite H3 in H0. rewrite perm_swap in H0. inversion H0...
    inversion H...
     rewrite <- H6 in H5.
    rewrite app_comm_cons in H5.
     pose proof (IHB1 (l::x0) C1 C2 H11 H9 H1 H2 H5)...
    rewrite  H3 in H2.
    inversion H2... inversion H... }
   { checkPermutationCases H3.
     inversion H... inversion H0...
     pose proof (IHB1 B2 C1 C2 H7 H9 H1 H2 H6)...
     checkPermutationCases H3. 
     rewrite H3 in H0. rewrite perm_swap in H0. inversion H0...
    inversion H...
     rewrite <- H6 in H5.
    rewrite app_comm_cons in H5.
     pose proof (IHB1 (l::x0) C1 C2 H11 H9 H1 H2 H5)...
    rewrite  H3 in H2.
    inversion H2... inversion H... }
Qed.

Lemma  ltgetLtX2 a b B: lt a b -> getLtX a (getLtX b B) = (getLtX b B).
Proof with sauto.
  intros.
 induction B...
 destruct a0 as [t F]. simpl...
 destruct (lt_dec b t)...
 assert(lt a t). 
 transitivity b...
  simpl...
destruct (lt_dec a t)...
 rewrite IHB...
Qed.

Lemma getLtXgetU k K : getLtX k (getU K) = getU (getLtX k K).
Proof with sauto.
  induction K;intros...
  destruct a as [a F].
  simpl. 
  destruct (uDec a)...
  - destruct (lt_dec k a)...
    + simpl...  destruct (lt_dec k a)...
       rewrite IHK...
    + simpl...  destruct (lt_dec k a)...
  - destruct (lt_dec k a)...
    + simpl...
Qed.

Lemma SetUgetLtX k K: SetU K -> SetU (getLtX k K).
Proof with sauto.
  induction K; intros...
  destruct a as [a F].
  simpl. 
  destruct (uDec a)...
  - destruct (lt_dec k a)...
    + apply Forall_cons... inversion H...
    + inversion H...
  - inversion H...
Qed.


Lemma getLtXgetL k K : getLtX k (getL K) = getL (getLtX k K).
Proof with sauto.
  induction K;intros...
  destruct a as [a F].
  simpl. 
  destruct (uDec a)...
  - destruct (lt_dec k a)...
    + simpl...
  - destruct (lt_dec k a)...
    + simpl...  destruct (lt_dec k a)...
       rewrite IHK...
    + simpl...  destruct (lt_dec k a)...
Qed.

Lemma LtXgetL k K: u k = true -> LtX k (getL K) -> SetU K.
Proof with sauto.
  induction K; intros...
  destruct a as [a F].
  simpl in *...
 destruct (uDec a)...
 apply Forall_cons...
 apply IHK...
 inversion H0...
 pose proof (uClosure k a H H3)...
Qed.
  

 Theorem Cut3 a b q P Q F L B C D:
    CutH (complexity P) (a+b) -> CutW  (complexity P) -> SetU B -> SetL C -> SetL D ->
    S (complexity Q) = complexity P ->
    SELLN th a ((q,Q)::(B++C)) L (DW F) -> 
    SELLN th b (B++D) [] (DW (Bang q  (Q ^))) ->   
    SELLS th (B++C++D) L (UP [F]).
  Proof with sauto;try solveLL.
  intros HC WC stB stC stD Hc' Ha Hb.
    inversion Ha...
   * inversion H3... 
      apply Forall_app in H2...
      pose proof (SETXempty C H0 stC)...
     enough (SetU D)...
  pose proof (SETXempty D H2 stD)...
    
     inversion Hb... 
    2:{ inversion H4. }
apply SetK4DestructL in stD...
  rewrite getLApp in H7. 
   apply Forall_app in H7...
   pose proof ( SETXLTEmpty q (getL D) H4 H6 H1)...
  apply linearEmpty in H7...

   * checkPermutationCases H4.
      - simpl in Hb.
        inversion Hb;solvePolarity... 2:{ inversion H1. }
        inversion H6...
  rewrite H2 in H0. apply Forall_app in H0...
      pose proof (SETXempty C H1 stC)...
eapply weakeningSet with (c:=q)...
   
        HProof.
     - checkPermutationCases H1. 
        { rewrite H2 in H0. inversion H0... 
           rewrite <- H3 in H6. apply Forall_app in H6... 
     pose proof (SETXempty C H4 stC)...
     pose proof (BangUnb H5 Hb).
    apply Forall_app in H6...
    pose proof (SETXempty D H8 stD)...
      LFocus (perp A). 
        solveLL. }
{ rewrite H1 in stC. inversion stC...
   rewrite H2 in H0. inversion H0...
    rewrite <- H3 in  H8.
   apply Forall_app in H8...
    pose proof (SETXempty x0 H4 H6)...
   pose proof (BangUnb H7 Hb).
    apply Forall_app in H1...
    pose proof (SETXempty D H9 stD)...
      LFocus (perp A). 
        solveLL. } 
        * inversion H3... 
      apply Forall_app in H2...
      pose proof (SETXempty C H0 stC)...
     enough (SetU D)...
  pose proof (SETXempty D H2 stD)...
   pose proof (BangUnb H1 Hb).

   apply Forall_app in H2...
 * cut3H H3 Hb. 
        apply InvPlus...
      * cut3H H3 Hb. 
        apply InvPlusComm...
      * checkPermutationCases H1. 
        {  rewrite H1 in H2. inversion H2...
            pose proof (unformUnb  stB stC H10 H3 H4 (symmetry H6))...
        
         rewrite H1 in H5, H9.
         rewrite <- app_comm_cons in H5, H9.
         rewrite <- H7 in H5, H9.
          cut3H H5 Hb. 
         cut3H H9 Hb.
   enough (SetU D).
             pose proof (SETXempty D H stD)...
   
         rewrite H0.
         rewrite H11.
         rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
               pose proof (BangUnb H8 Hb).
    apply Forall_app in H... }

        {  checkPermutationCases H1.
           assert(SetL x0). rewrite H1 in H3. inversion H3...
           assert(SetL x). rewrite <- H7. apply Forall_app...
            apply SetULPerm in H6...
          rewrite H1, H10 in H5. rewrite <- Permutation_middle in H5.
          cut3H H5 Hb. 
      
            rewrite H0, <- H10, <- H11, <- H7.
    LLPerm (B0++(x0++D)++D0).
         rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
           apply Forall_app...
      rewrite H10...
        apply unRelease... HProof.
           assert(SetL x0). rewrite H1 in H4. inversion H4...
           assert(SetL x). rewrite <- H7. apply Forall_app...
            apply SetULPerm in H6...
          rewrite H1, H10 in H9. rewrite <- Permutation_middle in H9.
          cut3H H9 Hb. 
      
            rewrite H0, <- H10, <- H11, <- H7.
    LLPerm (B0++C0++(x0++D)).
         rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
           apply Forall_app...
        apply unRelease... HProof.
      rewrite H10... }

     * inversion Hb...
        2:{ inversion H1. }

rewrite getLApp in *.
rewrite (SetU_then_empty B) in *...
(* rewrite (setLtoGetL D) in *. *)
simpl in *...
assert(LtX a0  (getL C)).
 { destruct (uDec q)... rewrite getLApp in H0.
       apply Forall_app in H0...
   inversion H0...
rewrite getLApp in H3.
       apply Forall_app in H3... }
  destruct (lt_dec a0 q).

pose proof (LtXTrans q a0 (getL D) H5 l). 
apply tri_store'... LFocus...
rewrite !getLApp. 
rewrite (SetU_then_empty B)...
apply Forall_app...
rewrite confBang in H6...
rewrite confBang in H4...
(* rewrite getLtXApp. *)
rewrite confBang...  2: apply Forall_app...
2: rewrite getLApp; apply Forall_app...
assert(LtX q (getL B)).
rewrite (SetU_then_empty B)...
apply Forall_nil.
pose proof (ltConv' a0 q B l H2)...
assert(SELLN th (S n0) (getLtX a0 B ++ D) [] (DW ((! q) (Q ^)))).
{ solveLL. rewrite getLApp'.
   rewrite <- getLtXgetL.
  apply Forall_app... 
rewrite (SetU_then_empty B)...
apply Forall_nil.
rewrite confBang...
rewrite H3.
setoid_rewrite getLtXApp.
rewrite getLtX_fixpoint.
rewrite getLtXgetU.
rewrite Permutation_assoc_comm.
apply weakeningGenN_rev... }
cut4H H4 H7. exact nil. apply SetUgetLtX... 

assert( u q = true).
{ destruct (uDec q)...
   inversion H0... }

rewrite confBang in H4...
rewrite confBang in H6...
pose proof(LtXgetL D H1 H5).
assert(SELLN th n ((q, Q) :: getLtX a0 B ++ C) [] (UP [F0])).
apply weakeningN...
apply tri_store'...
LFocus... 
rewrite !getLApp. 
rewrite (SetU_then_empty B)...
apply Forall_app...
rewrite (SetU_then_empty D)...
rewrite confBang...  2: apply Forall_app...
2: rewrite getLApp; apply Forall_app...
pose proof (SETXempty D H2 stD)...
HProof.
rewrite (SetU_then_empty D) ...
   *    cut3H H5 Hb.
        eapply InvEx with (t:=t)...
       * cut4H H4 Hb. 
  Qed. 

Lemma unReleaseN n
     : forall(B : list location) (M : list oo) (P : oo),
       SELLN th n B M (DW P) -> exists m, (n = m +1 \/ n <= m) /\ SELLN th m B M (UP [P]).
Proof with sauto.
  intros. 
  destruct (posOrNeg P).
  exists (S (S n))... 
  apply tri_store... 
  LFocus.
inversion H;solvePolarity... inversion H0.
exists n0... left. lia. 
Qed.

Lemma LtXgetLtX k K: LtX k (getLtX k K).
Proof with sauto.
  induction K...
  simpl... apply Forall_nil.
  destruct a as [a F].
  simpl... 
  destruct (lt_dec k a)...
  apply Forall_cons...
Qed.

Lemma ltLtXgetLtX p q K: lt p q -> LtX p (getLtX q K).
Proof with sauto.
  induction K;intros...
  simpl... apply Forall_nil.
  destruct a as [a F].
  simpl... 
  destruct (lt_dec q a)...
  apply Forall_cons... 
    transitivity q...
   apply IHK...
Qed.
  
Theorem Cut4  a b q P Q L M B  C D: 
CutH (complexity P) (a+b) -> CutW (complexity P) ->    
S (complexity Q) = complexity P -> SetU B -> SetL C -> SetL D ->  
  SELLN th a ((q,Q)::(B++C)) M (UP L) ->
  SELLN th b (B++D) [] (DW (Bang q (Q ^))) ->
  SELLS th (B++C++D) M (UP L).
Proof with sauto; try solveLL.  
  intros CH CW Hc stB stC stD Ha Hb.
  inversion Ha...  
  * cut4H H0 Hb.
  * cut4H H4 Hb.
  * cut4H H3 Hb.
  * cut4H H3 Hb.
  *   destruct (uDec i). 
     - LLPermH H3 ((q,Q)::(((i,F)::B)++C)). 
        apply weakeningN with (F:=(i,F)) in Hb...   
        rewrite app_comm_cons in Hb. cut4H H3 Hb.
    - LLPermH H3 ((q,Q)::(B++((i,F)::C))). 
      cut4H H3 Hb. 
       LLPerm (B ++ ((i, F) :: C) ++ D) ... 
  * apply H4 in properX. cut4H properX Hb.
  * cut4H H4 Hb.
  * destruct (posOrNeg F).
     cut3H H5 Hb. 
     assert( SELLS th (B++C++D) L' (UP [F]))...
     inversion H0;subst;try solve [inversion H].
     rewrite <- H1.
       HProof. 
     inversion H5;CleanContext...
     rewrite <- H1.
     LFocus...
     cut4H H8 Hb.
  * inversion H2...
      + cut3H H6 Hb. 
         assert(Hs: SELLS th (B++C++D) M (UP [F]))...
          apply seqtoSeqN in Hs.
          destruct Hs as [x Hs].
          assert(SetU D). 
         { apply BangUnb in Hb...
            apply Forall_app in Hb... }
          pose proof (InvBangT H0 Hb).
          apply seqtoSeqN in H2...
            destruct(posOrNeg F).
         {   assert(negFormula (F ^)).
            apply posDualNeg...
            assert( SELLN th x (B++C) M  (UP [F]) -> 
                    SELLN th (S x0) (B++D) [] (DW (F ^)) ->
                      SELLS th (B++C++D) (M++[])  (UP [ ])) as Cut1.
            eapply CW... 
            CleanContext. 
           apply Cut1... 
           pose proof (SETXempty D H stD)... } 
          {
            assert( SELLN th x0 (B++D) []  (UP [F^]) -> 
                  SELLN th (S x ) (B++C) M (DW ((F^)^)) ->
                      SELLS th (B++D++C) ([]++M) (UP [ ])) as Cut2.
            eapply CW...
            rewrite <- dualComplexity...
            rewrite <- dualInvolutive in Cut2.
            CleanContext.
            LLPerm (B++D++C). 
            apply Cut2...
pose proof (SETXempty D H stD)... }
       + apply in_app_or in H...
          {  eapply @AbsorptionClassic with  (F:=F) (i:=i)...
          cut3H H6 Hb. }
          {   apply InPermutation in H3...
              rewrite H3 in stC. inversion stC... }
 * checkPermutationCases H2.
  + rewrite H4 in H6. 
  inversion Hb...
2:{ inversion H2. }
        rewrite getLApp in H7.
             apply Forall_app in H7...

          rewrite confBang in H8...
assert(SELLN th n0 (B ++ D) [] (UP [Q ^])).
           eapply weakeningSetN with (c:=q)...
        rewrite getLApp...
             apply Forall_app... 
          rewrite confBang...
        assert( SELLN th n (B ++ C) M (DW (dual (dual Q)))).
       rewrite <- dualInvolutive...
          assert( SELLN th n0 (B ++ D) [] (UP [dual Q]) ->
                     SELLN th n (B ++ C) M (DW (dual (dual Q ))) -> SELLS th (B++D++C) M (UP [])).
        eapply CW...
        rewrite <- dualComplexity...
         LLPerm (B++D++C)...
  + checkPermutationCases H2.
     rewrite H2 in stB. inversion stB...
    rewrite <- H4 in H3.
    rewrite H3 in H6.
     eapply @AbsorptionLinear with  (F:=F) (i:=i) (B':= x0++D++B)...
     rewrite H2...
       destruct(posOrNeg F).
       2:{ inversion H6;solvePolarity... inversion H.
             cut4H H11 Hb. rewrite H2 in stC. inversion stC...
            LLPerm (B++x0++D)... } 
         {  
           clear H3 H4.
          inversion H6...
          -   inversion H8...
              apply BangUnb in Hb...
             apply Forall_app in Hb, H7... 
              apply Forall_app... apply Forall_app... 
         - checkPermutationCases H9. 
            rewrite H7 in H4. apply Forall_app in H4...
            rewrite H2 in stC. inversion stC...
            pose proof (SETXempty x0 H5 H10)...
            simpl in Hb. inversion Hb...
            rewrite Permutation_app_comm. 
            eapply weakeningSet with (c:=q)...
            apply seqNtoSeq in H12. inversion H12... inversion H4.
           checkPermutationCases H5.
           rewrite H2 in stC. inversion stC...
             rewrite H7 in H4. inversion H4...
            rewrite <- H8 in H12. apply Forall_app in H12...
            pose proof (SETXempty x0 H9 H11)...
            apply BangUnb in Hb... apply Forall_app in Hb...
            pose proof (SETXempty D H12 stD)...
            LFocus...
             rewrite H7 in H4. inversion H4...
           rewrite H2 in stC. inversion stC...
           rewrite <- H8 in H11. apply Forall_app in H11...
           rewrite H5 in H13. inversion H13...
            pose proof (SETXempty x1 H9 H15)...
           clear stC H9 H13 H15. 
 apply BangUnb in Hb... apply Forall_app in Hb... 
            pose proof (SETXempty D H9 stD)...
            LFocus... eapply tri_init2' with (i:=i0) (C:=B)...
          -   inversion H8...
              apply BangUnb in Hb...
             apply Forall_app in Hb, H7... 
              apply Forall_app... apply Forall_app... 
         - rewrite H2 in stC. inversion stC...
           destruct(posOrNeg F0).
       {        apply InvPlus...
                 LLStore.
                assert( SELLN th (S n0) ((q,Q)::(B++x0)) (F0::M) (UP [ ])).
                LFocus.
              cut4H H4 Hb. 
               LLPerm (B++x0++D).
              apply OLCut... }
             {   inversion H8;CleanContext...  
                 apply InvPlus...
                 cut4H H12 Hb.
                LLPerm(B++x0++D). HProof.  
               }
         - rewrite H2 in stC. inversion stC...
           destruct(posOrNeg G).
       {        apply InvPlusComm...
                 LLStore.
                assert( SELLN th (S n0) ((q,Q)::(B++x0)) (G::M) (UP [ ])).
                LFocus.
              cut4H H4 Hb. 
               LLPerm (B++x0++D).
              apply OLCut... }
             {   inversion H8;CleanContext...  
                 apply InvPlusComm...
                 cut4H H12 Hb.
                LLPerm(B++x0++D). HProof.  
               }
         - rewrite H2 in stC. inversion stC...
         checkPermutationCases H5.
    {  rewrite H5 in  H7. inversion H7...
        assert(SetU D). 
        apply BangUnb in Hb...   apply Forall_app in Hb...
           pose proof (unformUnb  stB H13 H16 H8 H9 (symmetry H11))...
              destruct(posOrNeg F0).
              * (* first *) 
                assert(SELLN th (S n0) (B0++C0) (F0::M0) (UP [])).
              LFocus F0.
              HProof. 
              rewrite H5 in H19.
              rewrite <- app_comm_cons in H19.
              rewrite <- H17 in H19.
              cut4H H19 Hb. 
              rewrite H18.
               LLPerm(B++(C0++D)++D0).
              rewrite H4. 
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app...

destruct(posOrNeg G).
2:{     inversion H14;solvePolarity...  inversion H20.  
assert( SELLN th n ((q, Q) :: (B ++ D0)) N (UP [G]) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ D0 ++ D) N (UP [G])) as CutG. 
             eapply CH with (cF:=P)...
            pose proof (SETXempty D H3 stD)...
            apply CutG...      LLExact H26. rewrite H5, H17... }

assert( SELLN th (S n0) ((q, Q) :: (B ++ D0)) (G::N) (UP []) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ D0 ++ D) (G::N) (UP [])) as CutG. 
             eapply CH with (cF:=P)...
            pose proof (SETXempty D H3 stD)...
             LLStore.
            apply CutG...   LFocus.   LLExact H14. rewrite H5, H17...
              * inversion H10; solvePolarity... inversion H12.
              rewrite H5 in H24.
              rewrite <- app_comm_cons in H24.
              rewrite <- H17 in H24.
              cut4H H24 Hb. 
              rewrite H18.
               LLPerm(B++(C0++D)++D0).
              rewrite H4. 
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
              apply Forall_app...

destruct(posOrNeg G).
2:{     inversion H14;solvePolarity...  inversion H12.  
assert( SELLN th n ((q, Q) :: (B ++ D0)) N (UP [G]) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ D0 ++ D) N (UP [G])) as CutG. 
             eapply CH with (cF:=P)...
            pose proof (SETXempty D H3 stD)...
            apply CutG...      LLExact H26. rewrite H5, H17... }

assert( SELLN th (S(S n)) ((q, Q) :: (B ++ D0)) (G::N) (UP []) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ D0 ++ D) (G::N) (UP [])) as CutG. 
             eapply CH with (cF:=P)...
            pose proof (SETXempty D H3 stD)...
             LLStore.
            apply CutG...   LFocus.   LLExact H14. rewrite H5, H17... }
  checkPermutationCases H5.
{
rewrite H5 in H8. inversion H8... 
apply SetULPerm in H11...
2:{ rewrite <- H12... 
    apply Forall_app... }
destruct(posOrNeg F0).
2:{     inversion H10;solvePolarity...  inversion H11.  
       rewrite H3, H5 in H23.
       LLPermH H23  ((q, Q) ::  B ++ x1).
      cut4H H23 Hb.
rewrite H4.
rewrite <- H15, <- H12. 
LLPerm (B++(x1++D)++D0).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
apply Forall_app... apply unRelease. rewrite <- H3. HProof.
 }
rewrite H4.
rewrite <- H15, <- H12. 
LLPerm (B++(x1++D)++D0).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
apply Forall_app... 
LLStore. 
2: apply unRelease; rewrite <- H3; HProof.
  
assert( SELLN th (S n0) ((q, Q) :: (B ++ x1)) (F0::M0) (UP []) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ x1 ++ D) (F0::M0) (UP [])) as Cut. 
             eapply CH with (cF:=P)...
             apply Cut...   LFocus.   LLExact H10. rewrite H5, H3... }
rewrite H5 in H9. inversion H9... 
apply SetULPerm in H11...
2:{ rewrite <- H12... 
    apply Forall_app... }
destruct(posOrNeg G).
2:{     inversion H14;solvePolarity...  inversion H11.  
       rewrite H3, H5 in H23.
       LLPermH H23  ((q, Q) ::  B ++ x1).
      cut4H H23 Hb.
rewrite H4.
rewrite <- H15, <- H12. 
LLPerm (B++C0++(x1++D)).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
apply Forall_app... apply unRelease. rewrite <- H3. HProof.
 }

rewrite H4.
rewrite <- H15, <- H12. 
LLPerm (B++C0++(x1++D)).
              rewrite <- (app_nil_l [ ]).
              eapply @InvTensor...
apply Forall_app... 
 apply unRelease; rewrite <- H3; HProof.
LLStore. 
  
assert( SELLN th (S n0) ((q, Q) :: (B ++ x1)) (G::N) (UP []) ->
        SELLN th b (B ++ D) [] (DW ((! q) (Q ^))) ->
        SELLS th (B ++ x1 ++ D) (G::N) (UP [])) as Cut. 
             eapply CH with (cF:=P)...
             apply Cut...   LFocus.   LLExact H14. rewrite H5, H3... 

- inversion Hb... 
   2:{ inversion H5. } 
rewrite getLApp in H10.
rewrite app_comm_cons in H4.
setoid_rewrite getLApp in H4.
apply Forall_app in H4, H10...
simpl in H9...
destruct (lt_dec a q)...
pose proof(LtXTrans q a (getL D) H5 l).
pose proof(LtXTrans q a (getL B) H3 l).
LLPerm(B++x0++D).
LLStore. LFocus...
do 2 setoid_rewrite getLApp.
apply Forall_app... apply Forall_app...
rewrite confBang...
2:{ apply Forall_app... rewrite H2 in stC. inversion stC... }
2:{  rewrite getLApp'.  apply Forall_app... }
rewrite confBang in H9, H11... 
2:{ rewrite H2 in stC. inversion stC... }
pose proof (ltConv' a q B l H3)...
assert(Hb': SELLN th (S n) (getLtX a B ++ D) [] (DW ((! q) (Q ^)))).
rewrite H12. 
LLPerm ((getLtX q B ++ D) ++ getU x).
apply weakeningGenN_rev...
rewrite getLApp'. 
rewrite <- getLtXgetL.
apply Forall_app...
apply LtXgetLtX...
rewrite confBang... 
rewrite getLtX_fixpoint...
cut4H H9 Hb'. exact nil.
apply SetUgetLtX...
rewrite H2 in stC. inversion stC...

rewrite confBang in H9, H11... 
2: rewrite H2 in stC; inversion stC...
assert( u q = true).
{ destruct (uDec q)... simpl in H7...
   inversion H7... }
 pose proof(LtXgetL D H4 H5). 
 pose proof (SETXempty D H10 stD)...
LLPerm (B++x0).
LLStore. LFocus...
rewrite getLApp'.
apply Forall_app...
rewrite( SetU_then_empty B)...
rewrite confBang... 
HProof. rewrite H2 in stC. inversion stC...
         - rewrite H2 in stC. inversion stC...
           destruct(posOrNeg (FX t)).
       {        apply InvEx with (t:=t)...
                 LLStore.
                assert( SELLN th (S n0) ((q,Q)::(B++x0)) (FX t::M) (UP [ ])).
                LFocus.
              cut4H H7 Hb. 
               LLPerm (B++x0++D).
              apply OLCut... }
             {  inversion H10;subst;auto;
               try match goal with 
               [ H1: _ = FX t, H2: negFormula (FX t) |- _] => rewrite <- H1 in H2;inversion H2
                end. 
                 apply @InvEx with (t:=t)...
                 cut4H H14 Hb. 
               LLPerm(B++x0++D)... }
- apply posNotNeg in H... }

* cut3H H5 Hb. 
        assert(Hs:SELLS th (B++C++D) M (UP [F]))...
             destruct (negAtomDec F).
              2:{  eapply @AbsorptionTheory with (F:=F)... }
             inversion H...
             eapply @AbsorptionPerp' with (A:=A)...
  Qed.
  
 
  Theorem CutElimination i j A B C D cF L M N P: SetU B -> SetL C -> SetL D ->
      (SELLN th i (B++C) (cF::M) (UP L) -> 
      SELLN th j (B++D) N (UP [dual cF]) -> 
      SELLS th (B++C++D) (M ++ N) (UP L)) /\
      (SELLN th i (B++C) M (UP (cF :: L)) -> 
      SELLN th j (B++D) N (DW (dual cF)) -> 
      SELLS th (B++C++D) (M ++ N) (UP L)) /\
       (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (DW P) -> 
       SELLN th j (B++D) [] (DW (Bang a (dual A))) -> 
       SELLS th (B++C++D) M (UP [P]))  /\
      (forall a, S (complexity A) = complexity cF ->
       SELLN th i ((a,A)::(B++C)) M (UP L) -> 
       SELLN th j (B++D) [] (DW (Bang a (dual A))) -> 
       SELLS th  (B++C++D) M (UP L)).
  Proof with sauto;solvePolarity; try solveLL.

assert(exists w, complexity cF = w).
    eexists; auto.
    destruct H as [w H].
    revert H.
    revert i j cF C A D P B L M N.
    
    induction w using lt_wf_ind; intros. 

     remember (plus i j) as h.
      revert dependent B.
    revert dependent C.
      revert dependent D.
      revert dependent L.
      revert dependent M.
      revert dependent N.
      revert dependent P.
      revert A.
      revert dependent cF.
      revert dependent i.
      revert j.
      induction h using lt_wf_ind; intros.
      assert(CutW (complexity cF)).
   unfold CutW;intros. eapply H with (m:=complexity cF0)... 
   clear H.
 
  assert(CutH (complexity cF) (i+j)).
   unfold CutH;intros. eapply H0 with (m:=i0+j0)... 
     clear H0.
 rename H1 into compC.
        
        move B at top.
        move L at top.
        move M at top.
        move N at top.
        
        move C at top.
        move A at top.
        move P at top.
        
        subst.
        split;[intros | 
        split;[intros | 
        split;intros]].
        * refine (Cut1 _  _ _ _ H0 H1)...
        * refine (Cut2 _  _ _ _ _ H0 H1)...
        * refine (Cut3 _  _ _ _ _ _ H0 H1 H6)...
        * refine (Cut4 _  _ _ H0 _ _ _ H1 H6)...
Qed.
          
  Theorem GeneralCut i j P B C D L M N: 
   SetU B -> SetL C -> SetL D -> SELLN th i (B++C) M (UP (P::L)) -> 
                   SELLN th j (B++D) N (DW (dual P)) -> 
                                 SELLS th (B++C++D) (M++N ) (UP L).
  Proof with subst;auto.
    assert(exists w, complexity P = w). 
    eexists; auto.
    destruct H as [w H].
    apply CutElimination...   Qed.
  
  Theorem GeneralCut' P B C D L M N:  
      SetU B -> SetL C -> SetL D -> 
      SELLS th (B++C) M  (UP (P :: L)) ->
      SELLS th (B++D) N  (DW (dual P)) ->
      SELLS th (B++C++D) (M ++ N) (UP L).
  Proof.
    intros.
    apply seqtoSeqN in H2, H3...
    CleanContext.
    eapply GeneralCut with (P:= P);eauto.
  Qed.

End CutElimination.
