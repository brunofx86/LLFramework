(** * System MALL for propositional multiplicative and additive linear logic

This file encodes the inference rules of the system MALL (two sided)
of propositional multiplicative additive linear logic.
 *)

Require Import LL.Misc.Permutations.
Require Export LL.SL.FLL.Specifications.Substructural.OLCut.
Set Implicit Arguments.

 
(** ** Syntax *)
(* conjunction, disjunction and implication *)
Inductive MALLCon := TENSOR | PAR | WITH | OPLUS .

#[local]Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    ccon := Empty_set ;
    ucon := Empty_set;
    bcon := MALLCon ;
    qcon := Empty_set
  |}.


(** ** Inference rules *)

(** *** Constants *)
Definition MALLrulesC (c:ccon) :=
  match c return ruleC with
  end.

(** *** Unary connectives *)
Definition MALLrulesU  (c:ucon) :=
  match c return ruleU with
  end.

(** *** Binary connectives *)
Definition MALLrulesB (c :bcon) :=
  match c with
  | TENSOR => {| rb_rgtBody := fun F G => MAnd (atom (up F)) (atom (up G) );
                 rb_lftBody  := fun F G => MOr (atom (down F) ) (atom (down G)) |}
  | PAR => {| rb_rgtBody := fun F G => MOr (atom (up F)) (atom (up G) );
              rb_lftBody  := fun F G => MAnd (atom (down F) ) (atom (down G)) |}
  | WITH => {| rb_rgtBody := fun F G => AAnd (atom (up F)) (atom (up G) );
                 rb_lftBody  := fun F G => AOr (atom (down F) ) (atom (down G)) |}
  | OPLUS => {| rb_rgtBody := fun F G => AOr (atom (up F)) (atom (up G) );
             rb_lftBody  := fun F G => AAnd (atom (down F) ) (atom (down G)) |}
  end.

(** *** Quantifiers *)
Definition MALLrulesQ (c :qcon) :=
  match c return ruleQ with
  end.


#[local] Instance SimpleOORUles : OORules :=
  {|
    rulesC := MALLrulesC;
    rulesU := MALLrulesU ;
    rulesB := MALLrulesB;
    rulesQ := MALLrulesQ
  |}.

(** ** Well-formedness conditions *)

(** *** Constants *)
Lemma wellFormedMALLC : wellFormedC.
Proof with sauto.
  unfold wellFormedC;intros.
  destruct lab.
Qed.


(** *** Unary connectives *)

Lemma wellFormedMALLU : wellFormedU.
Proof with sauto. 
  unfold wellFormedU;intros.
  destruct lab.
Qed.


(** *** Binary connectives *)
Lemma wellFormedMALLB : wellFormedB.
Proof with sauto.
  unfold wellFormedB;intros.
  destruct lab;destruct s.
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  invTri H8.
  invTri H9.
  invTri H6.
  invTri H10.

    exists [⌊ Go1 ⌋;⌊ Fo1 ⌋ ].
    exists n0, 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    simpl. solveLL. 
    apply seqNtoSeq in H9...
    LLExact H9.
    lia.
    intros.
    TFocus ((makeLRuleB TENSOR Fo1 Go1)).
    inversion H4.
    FLLsplit [⌊ t_bcon TENSOR Fo1 Go1 ⌋] Delta1.
    simpl. solveLL. 
    LLExact H2.
  - 
    invTri H8.
    invTri H10.
    invTri H8.
    invTri H11.
    exists [⌊ Go1 ⌋;⌊ Fo1 ⌋].
    exists n0, 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    simpl. solveLL.
    apply seqNtoSeq in H10...
    LLExact H10.
    LLExact H10.
    rewrite H3...
    lia.
    intros.
    simpl. solveLL.
    LLExact H1.  
  +
  exists BTwoPM.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H10.
    invTri H11.
    invTri H9.
    invTri H10. 
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    rewrite H3...
    rewrite H4...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    apply seqNtoSeq in H11.
    LLExact H11.
    LLExact H12.
    LLExact H11.
    lia.
    intros.
    TFocus ((makeRRuleB TENSOR Fo1 Go1)).
    inversion H6.
    FLLsplit [⌈ t_bcon TENSOR Fo1 Go1 ⌉] ( Delta1 ++ Delta2).
    simpl...
    FLLsplit Delta1 Delta2.
    solveLL.
    LLExact H2.
    solveLL.
    LLExact H5.
  --
    invTri H8.
    invTri H11.
    invTri H12.
    invTri H10.
    invTri H11.
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉], [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H13.
    LLExact H13.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    LLExact H13.
    LLExact H12.
    lia.
    intros.
    simpl...
    FLLsplit Delta1 Delta2. 
    solveLL.
    LLExact H1.
    solveLL.
    LLExact H2.     
  +
  exists BTwoPM.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H10.
    invTri H11.
    invTri H9.
    invTri H10. 
    eexists M.
    eexists N0.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    rewrite H3...
    rewrite H4...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    apply seqNtoSeq in H11.
    LLExact H11.
    LLExact H12.
    LLExact H11.
    lia.
    intros.
    TFocus ((makeLRuleB PAR Fo1 Go1)).
    inversion H6.
    FLLsplit [⌊ t_bcon PAR Fo1 Go1 ⌋] ( Delta1 ++ Delta2).
    simpl...
    FLLsplit Delta1 Delta2.
    solveLL.
    LLExact H2.
    solveLL.
    LLExact H5.
  --
    invTri H8.
    invTri H11.
    invTri H12.
    invTri H10.
    invTri H11.
    eexists M.
    eexists N0.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H13.
    LLExact H13.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    LLExact H13.
    LLExact H12.
    lia.
    intros.
    simpl...
    FLLsplit Delta1 Delta2. 
    solveLL.
    LLExact H1.
    solveLL.
    LLExact H2.   
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  invTri H8.
  invTri H9.
  invTri H6.
  invTri H10.
    exists [⌈ Go1 ⌉; ⌈ Fo1 ⌉ ].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    simpl. solveLL. 
    apply seqNtoSeq in H9...
    LLExact H9.
    lia.
    intros.
    TFocus ((makeRRuleB PAR Fo1 Go1)).
    inversion H4.
    FLLsplit [⌈ t_bcon PAR Fo1 Go1 ⌉] Delta1.
    simpl. solveLL. 
    LLExact H2.
  - 
    invTri H8.
    invTri H10.
    invTri H8.
    invTri H11.
    exists [⌈ Go1 ⌉;⌈ Fo1 ⌉].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    simpl. solveLL.
    apply seqNtoSeq in H10...
    LLExact H10.
    LLExact H10.
    rewrite H3...
    lia.
    intros.
    simpl. solveLL.
    LLExact H1.  
      +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌊ Fo1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleB WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bcon WITH Fo1 Go1 ⌋] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleB WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bcon WITH Fo1 Go1 ⌋] Delta1.
    FLLright.
    FLLrelease.
    FLLstore.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌊ Fo1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.    
   +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeRRuleB WITH Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bcon WITH Fo1 Go1 ⌉] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11. rewrite H3...
    LLExact H10. rewrite H3...
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.    
       
       +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeLRuleB OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bcon OPLUS Fo1 Go1 ⌋] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11. rewrite H3...
    LLExact H10. rewrite H3...
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.
       +
  exists  BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌈ Fo1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleB OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bcon OPLUS Fo1 Go1 ⌉] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleB OPLUS Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bcon OPLUS Fo1 Go1 ⌉] Delta1.
    FLLright.
    FLLrelease.
    FLLstore.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌈ Fo1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌈ Go1 ⌉].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.
Qed.

(** *** Quantifiers *)
Lemma wellFormedMALLQ : wellFormedQ.
Proof with sauto.
  unfold wellFormedQ. intros.
  destruct lab.
Qed.

Lemma wellFormedTheoryMALL : wellFormedTheory.
Proof.
  split.
  apply wellFormedMALLC.
  split.
  apply wellFormedMALLU.
  split; [apply wellFormedMALLB | apply wellFormedMALLQ].
Qed.

(** ** Cut-coherency properties *)

Require Import SL.FLL.InvPositivePhase.

(** *** Binary Connectives *)
Lemma CutCoherenceTENSOR: CutCoherenceBin cutR1 (rulesB TENSOR).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm ((⌊ F ⌋^ ⊗ ⌊ G ⌋^):: ([⌈ F ⌉^] ++ [⌈ G ⌉^])).
  apply InvTensor'...
Qed. 
  
Lemma CutCoherencePAR: CutCoherenceBin cutR1 (rulesB PAR).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm ((⌈ F ⌉^ ⊗ ⌈ G ⌉^):: ([⌊ F ⌋^] ++ [⌊ G ⌋^])).
  apply InvTensor'...
Qed. 
  

Lemma CutCoherenceWITH: CutCoherenceBin cutR1  (rulesB WITH).
Proof with sauto;try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
   LLPerm ((⌈ F ⌉^ ⊕ ⌈ G ⌉^):: ([⌊ F ⌋^])).
  apply InvPlus...
   LLPerm ((⌈ F ⌉^ ⊕ ⌈ G ⌉^):: ([⌊ G ⌋^])).
  apply InvPlusComm...
Qed. 


Lemma CutCoherenceOPLUS: CutCoherenceBin cutR1  (rulesB OPLUS).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
   LLPerm ((⌊ F ⌋^ ⊕ ⌊ G ⌋^):: ([⌈ F ⌉^])).
  apply InvPlus...
   LLPerm ((⌊ F ⌋^ ⊕ ⌊ G ⌋^):: ([⌈ G ⌉^])).
  apply InvPlusComm...
Qed.

Lemma CutCoherenceMALL : CutCoherence cutR1.
Proof.
  split;intros. 
  destruct lab...
  split;intros; try destruct lab.
  split;intros; try destruct lab. 
  apply CutCoherenceTENSOR.
  apply CutCoherencePAR.
  apply CutCoherenceWITH.
  apply CutCoherenceOPLUS.
Qed.
 
Check OLCutElimination wellFormedTheoryMALL CutCoherenceMALL. 
(* 
Notation "( th ) ⊢ B ';' L ⇑ F " := (seq th B L (UP F))  (at level 80).
Notation "( th ) n ⊢ B ';' L ⇑ F " := (seqN th n B L (UP F))  (at level 80).


Check OLCutElimination wellTheory_p.
 *)
(** ** Adequacy 

Now we prove that the encoding is sound and complete. For that, we
define the provability relation of MALL as an inductive definition *)

Notation "F *** G" := (t_bcon TENSOR F G) (at level 10) .
Notation "F $$$ G" := (t_bcon PAR F G) (at level 10) .
Notation "F 'ooo' G" := (t_bcon OPLUS F G) (at level 10) .
Notation "F &* G" := (t_bcon WITH F G) (at level 10) .

Record cutrule := {
  cut : bool   }.


Inductive MALLSeq {P} {n} : list uexp -> list uexp -> Prop :=
| MALLInit : forall F , MALLSeq [F] [F]
| MALLTensorR : forall L1 L2 L1' L2' F G, MALLSeq L1 (F :: L2) -> MALLSeq L1' (G :: L2') -> MALLSeq  (L1 ++ L1') (F *** G :: (L2 ++ L2'))
| MALLTensorL : forall L1 L2 F G, MALLSeq (F :: G :: L1) L2 -> MALLSeq (F *** G :: L1) L2
| MALLParR : forall L1 L2 F G, MALLSeq L1 (F :: G :: L2) -> MALLSeq L1 (F $$$ G :: L2)
| MALLParL :forall L1 L2 L1' L2' F G, MALLSeq (F :: L1) L2 -> MALLSeq (G :: L1') L2' -> MALLSeq (F $$$ G :: L1 ++ L1') (L2 ++ L2')
| MALLOpRE1 : forall L1 L2 F G, MALLSeq L1 (F :: L2) -> MALLSeq L1 (F ooo G :: L2)
| MALLOpRE2 : forall L1 L2 F G, MALLSeq L1 (G :: L2) -> MALLSeq L1 (F ooo G :: L2)
| MALLOpL : forall L1 L2 F G, MALLSeq (F :: L1) L2 -> MALLSeq (G :: L1) L2 -> MALLSeq (F ooo G :: L1) L2
| MALLWithR : forall L1 L2 F G, MALLSeq L1 (F :: L2) -> MALLSeq L1 (G :: L2) -> MALLSeq L1 (F &* G :: L2)
| MALLWithL1 : forall L1 L2 F G, MALLSeq (F :: L1) L2 ->  MALLSeq (F &* G :: L1) L2
| MALLWithL2 : forall L1 L2 F G, MALLSeq (G :: L1) L2 ->  MALLSeq (F &* G :: L1) L2
| MALLExR : forall  L1 L2 L2', Permutation L2 L2' -> MALLSeq L1 L2' -> MALLSeq L1 L2
| MALLExL : forall  L1 L2 L1', Permutation L1 L1' -> MALLSeq L1' L2 -> MALLSeq L1 L2
| MALLCut {f : cut P = true}: forall F L1 L2 R1 R2, lengthUexp F n ->  isOLFormula F -> MALLSeq (F::L1) R1 -> MALLSeq L2 (F::R2) -> MALLSeq (L1++L2) (R1++R2).

Definition wc := {| cut:= true |}. (* with cut *)
Definition wnc :=  {| cut:= false |}. (* with no cut *)


Global Instance MALLL_morph w n: 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> iff) (MALLSeq (P:=w) (n:=n)).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply MALLExR with (L2':=x0);auto.
  eapply MALLExL with (L1':=x);auto.
  eapply MALLExR with (L2':=y0);auto.
  eapply MALLExL with (L1':=y);auto. 
Qed.

Local Hint Constructors MALLSeq : core.

Theorem SoundnessMALL: forall n L1 L2, 
                   MALLSeq (P:=wnc) (n:=n) L1 L2 -> MALLSeq (P:=wc) (n:=n) L1 L2.
Proof with sauto. 
    intros *. 
    intros HM.
   induction HM;simpl...
   rewrite H...
  rewrite H...
Qed.

 
Theorem SoundenessFLL: forall n L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wnc) (n:=n) L1 L2 ->
                                flls (OLTheory nPnN) []  ( (LEncode L1) ++  (REncode L2)) (UP []).
Proof with sauto; try OLSolve. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
  + TFocus (RINIT F).
      inversion H.
     apply ooth_init.
     inversion isFL2...
     FLLsplit [⌈ F ⌉] [⌊ F ⌋] ;solveLL.
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleB TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F *** G ⌉] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉:: ⌜ L2 ⌝).
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
   LLPerm (⌞ L1' ⌟ ++ ⌈ G ⌉ :: ⌜ L2' ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleB TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F *** G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌊ F ⌋ :: ⌊ G ⌋ :: ⌞ L1 ⌟ ++ ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleB PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F $$$ G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleB PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F $$$ G ⌋ ] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 

   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleB OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeRRuleB OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleB OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F ooo G ⌋ ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleB WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [ ⌈ F &* G ⌉  ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝) .
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleB WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeLRuleB WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + rewrite H in isFL2. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌈ x ⌉) ) in H.
      rewrite H. apply IHHM...
  + rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H. apply IHHM...
Qed.

Require Import LL.SL.FLL.Reasoning.
  
Theorem CompletenessFLL: forall x n L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                 flln (OLTheory nPnN) x []  ( (LEncode L1) ++  (REncode L2)) (UP []) ->
                 MALLSeq (P:=wnc) (n:=n) L1 L2.
Proof with sauto;try solveLL; try OLSolve.
  induction x using lt_wf_ind; intros *.  
  intros HisL1 HisL2  Hseq. 
  inversion Hseq...
 cut(False);intros...
 refine (onlyAtomsLinear _ H0 H1)...
 apply isOLLEncode... 
 apply isOLREncode...
  inversion H1...
  inversion H3...
  1-4:  destruct C...
  3-4:  destruct C...
 + apply FocusingClause in H2...
    apply checkEncodeCasesU in H7... 
    apply OLInPermutation' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingTensor in H8... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLTensorR.
         eapply H with (m:=x2)...
         inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
        inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPar in H8... 
          eapply MALLParR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLWithR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H10.
         rewrite <- H5...
    ++ apply FocusingPlus in H8... 
          eapply MALLOpRE1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
          eapply MALLOpRE2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
 + apply FocusingClause in H2...
    apply checkEncodeCasesD in H7... 
    apply OLInPermutationL' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingPar in H8... 
          eapply MALLTensorL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingTensor in H8... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLParL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPlus in H8... 
          eapply MALLWithL1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
          eapply MALLWithL2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLOpL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H10.
         rewrite <- H5...
 + apply FocusingInitRuleU in H2...
     simpl in H4. 
    apply checkEncodeCasesU in H4...
    assert(In (⌊ OO ⌋) (⌜ L2 ⌝)).
    rewrite H2. rewrite H7.
    firstorder.
   apply NoDinR in H4...
   rewrite H7 in H2...
   assert(L1 = [OO]).
   eapply MapLEncodeEqual... 
   assert(L2 = [OO]).
   eapply MapREncodeEqual...
   rewrite H4, H5...
+ inversion f.
+ inversion f.
Qed.

Theorem SoundenessCFLL: forall x L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wc) (n:=x) L1 L2 ->
                     flls (OLTheoryCut nPnN x) []  ( (LEncode L1) ++  (REncode L2)) (UP []).
Proof with sauto; try solveLL; try OLSolve. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
  +  TFocus (RINIT F).
      inversion H.
     apply oothc_theory.
     apply ooth_init.
     inversion isFL2...
     FLLsplit [⌈ F ⌉] [⌊ F ⌋] ;solveLL.
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleB TENSOR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F *** G ⌉] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉:: ⌜ L2 ⌝).
   apply IHHM1... 
     inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
   LLPerm (⌞ L1' ⌟ ++ ⌈ G ⌉ :: ⌜ L2' ⌝).
   apply IHHM2... 
     inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleB TENSOR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F *** G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌊ F ⌋ :: ⌊ G ⌋ :: ⌞ L1 ⌟ ++ ⌜ L2 ⌝)...
   apply IHHM...
 inversion isFL1...
     inversion H1...
     inversion H...
 inversion isFL1...
     inversion H1...
     inversion H...
 inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleB PAR F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F $$$ G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌈ G ⌉ :: ⌜ L2 ⌝)...
   apply IHHM... 
   inversion isFL2...
     inversion H1...
     inversion H...
   inversion isFL2...
   
     inversion H1...
     inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleB PAR F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F $$$ G ⌋ ] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp...
   apply IHHM1...
     inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
      apply IHHM2...
 inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
    + simpl in IHHM...
     TFocus (makeRRuleB OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝)...
    apply IHHM...
   inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
   + simpl in IHHM...
     TFocus (makeRRuleB OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝)...
   apply IHHM...
  inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleB OPLUS F G). 
     inversion H.
    apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F ooo G ⌋ ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   apply IHHM1...
   inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
   apply IHHM2...
   inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...

  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleB WITH F G). 
     inversion H.
   apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [ ⌈ F &* G ⌉  ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝) .
  apply IHHM1... inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
     
  LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
  apply IHHM2... inversion isFL2...
     inversion H1...
     inversion H...
     inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleB WITH F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
     simpl;solveLL.
     FLLleft...
    apply IHHM...
   inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
  + simpl in IHHM...
     TFocus (makeLRuleB WITH F G). 
     inversion H.
     apply oothc_theory.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
     simpl;solveLL.
     FLLright...
    apply IHHM...
   inversion isFL1...
     inversion H1...
     inversion H...
     inversion isFL1...
  + simpl in IHHM...
     rewrite H in isFL2. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌈ x ⌉) ) in H.
      rewrite H... 
  + simpl in IHHM...
     rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H... 
   + simpl in IHHM1,IHHM2...
     TFocus (RCUT F).
     inversion H1.
    eapply oothc_cutn.
    eapply ctn with (m:=x)... firstorder.
    FLLsplit ( ⌞ L2 ⌟ ++ ⌜ R2 ⌝) (⌞ L1 ⌟ ++ ⌜ R1 ⌝) .
    rewrite LEncodeApp, REncodeApp...
    1-2: solveLL.
   
    LLPerm (⌞ L2 ⌟ ++ ⌈ F ⌉ :: ⌜ R2 ⌝).
    apply IHHM2...
   inversion isFL2...
    apply IHHM1...
   inversion isFL2...
  Qed.
 Theorem CutElimMALL: forall x L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                  MALLSeq (P:=wc) (n:=x) L1 L2 -> MALLSeq (P:=wnc) (n:=x) L1 L2.
Proof with sauto.
 intros.
 apply  SoundenessCFLL in H1...
 specialize(OLCutElimination wellFormedTheoryMALL CutCoherenceMALL);intros.
 apply seqtoSeqN in H1...
 apply H2 in H1... all:clear H2.
 apply seqtoSeqN in H1...
eapply CompletenessFLL with (n:=x) in H1...
apply Forall_app...
apply isOLLEncode...
apply isOLREncode...
Qed.
 
Theorem CompletenessCFLL: forall x n L1 L2, 
                            isOLFormulaL L1 ->
                                isOLFormulaL L2 ->
                 flln (OLTheoryCut nPnN n) x []  ( (LEncode L1) ++  (REncode L2)) (UP []) ->
                 MALLSeq (P:=wc) (n:=n) L1 L2.
Proof with sauto;try solveLL; try OLSolve.

  induction x using lt_wf_ind; intros *.  
  intros HisL1 HisL2 Hseq. 
  inversion Hseq...
 cut(False);intros...
 refine (onlyAtomsLinear _ H0 H1)...
 apply isOLLEncode... 
 apply isOLREncode...
  inversion H1...
  inversion H3...
  inversion H4...
  1-4:  destruct C...
  3-4:  destruct C...
  4:{  inversion f. } 4:{ inversion f. }
  4:{ inversion H3...
   -
revert dependent L1.
revert dependent L2. 
revert dependent F0. induction n using lt_wf_ind; intros .  

  apply FocusingTensor in H7...
   apply destructEncode in H10...
   rewrite H8, H14.

  eapply MALLCut with (F:=F0)...
Search lengthUexp.
     simpl in H4. 
    apply checkEncodeCasesU in H4...
    assert(In (⌊ OO ⌋) (⌜ L2 ⌝)).
    rewrite H2. rewrite H7.
    firstorder.
   apply NoDinR in H4...
   rewrite H7 in H2...
   assert(L1 = [OO]).
   eapply MapLEncodeEqual... 
   assert(L2 = [OO]).
   eapply MapREncodeEqual...
   rewrite H4, H5...



 + apply FocusingClause in H2...
    apply checkEncodeCasesU in H8... 
    apply OLInPermutation' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingTensor in H9... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLTensorR.
         eapply H with (m:=x2)...
         inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
        inversion H4...
         inversion H5...
         rewrite H13 in H2.
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPar in H8... 
          eapply MALLParR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLWithR.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H10.
         rewrite <- H5...
    ++ apply FocusingPlus in H8... 
          eapply MALLOpRE1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
          eapply MALLOpRE2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL2.
         inversion HisL2...
         LLExact H8.
         rewrite <- H5...
 + apply FocusingClause in H2...
    apply checkEncodeCasesD in H7... 
    apply OLInPermutationL' in H2...
    rewrite H2...
    destruct C...
    ++ apply FocusingPar in H8... 
          eapply MALLTensorL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite <- H5...
    ++ apply FocusingTensor in H8... 
          rewrite H9 in H5.
         apply destructEncode in H5...
         rewrite H8, H13.
         eapply MALLParL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H7.
         rewrite H6...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H5...
         rewrite H8 in H2.
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H11.
         rewrite H10...
    ++ apply FocusingPlus in H8... 
          eapply MALLWithL1.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
          eapply MALLWithL2.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
    ++ apply FocusingWith in H8... 
          eapply MALLOpL.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H9.
         rewrite <- H5...
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H10.
         rewrite <- H5...
 + apply FocusingInitRuleU in H2...
     simpl in H4. 
    apply checkEncodeCasesU in H4...
    assert(In (⌊ OO ⌋) (⌜ L2 ⌝)).
    rewrite H2. rewrite H7.
    firstorder.
   apply NoDinR in H4...
   rewrite H7 in H2...
   assert(L1 = [OO]).
   eapply MapLEncodeEqual... 
   assert(L2 = [OO]).
   eapply MapREncodeEqual...
   rewrite H4, H5...
Qed.


Lemma OLFormulaLeng F: isOLFormula F -> exists x, lengthUexp F x.
Proof with sauto.
 intro H. induction H;intros...
 - eexists...
 - inversion H...
    eexists...
 - eexists (S x)...
 - eexists (S (x0+x))...
 - assert(proper  (Var 0%nat)). 
    apply proper_VAR. 
    apply H1 in H2... 
    eexists (S x)...
Qed.
   
