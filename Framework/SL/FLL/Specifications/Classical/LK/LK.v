(** * System LK for classical logic encoded as an LL theory

This file encodes the inference rules of the system LK. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)

Require Export LL.OL.Classical.OLCut.
Require Import Coq.Init.Nat.
Require Import LL.Framework.SL.Focused.FLLReasoning.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.
 
(** ** Syntax *)
(* No units *)
Inductive Constants := TT | FF.
(* conjunction, disjunction and implication *)
Inductive Connectives := AND | OR | IMP .
(* no quantifiers *)
Inductive Quantifiers := .
(* no unary connectives *) 
Inductive UConnectives := .

#[local]Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    constants := Constants ;
    uconnectives := UConnectives;
    connectives := Connectives ;
    quantifiers := Quantifiers
  |}.


(** ** Inference rules *)

(** *** Constants *)
Definition rulesCTE (c:constants) :=
  match c return ruleCte with
 | TT => {| rc_rightBody := Top;
                  rc_leftBody  := Zero |}
 | FF => {| rc_rightBody := Zero;
                  rc_leftBody  := Top |}
  
  end.

(** *** Unary connectives *)
Definition rulesUC  (c:uconnectives) :=
  match c return ruleUnary with
  end.

(** *** Binary connectives *)
Definition rulesBC (c :connectives) :=
  match c with
  | AND => {| rb_rightBody := fun F G => AAnd  (atom (up F)) (atom (up G) );
                 rb_leftBody  := fun F G => AOr (atom (down F) ) (atom (down G)) |}
  | OR => {| rb_rightBody := fun F G => AOr  (atom (up F)) (atom (up G) );
              rb_leftBody  := fun F G => AAnd  (atom (down F) ) (atom (down G)) |}
  | IMP => {| rb_rightBody := fun F G => MOr (atom (down F)) (atom (up G) );
                 rb_leftBody  := fun F G =>MAnd (atom (up F) ) (atom (down G)) |}
  end.

(** *** Quantifiers *)
Definition rulesQC (c :quantifiers) :=
  match c return ruleQ with
  end.


#[local] Instance SimpleOORUles : OORules :=
  {|
    rulesCte := rulesCTE ;
    rulesUnary := rulesUC ;
    rulesBin := rulesBC;
    rulesQ := rulesQC
  |}.
  
  
 (** *** Constants *)
Lemma wellFormedConstant : wellFormedCte.
Proof with sauto.
  unfold wellFormedCte;intros.
  destruct lab;destruct s.
  -
  exists BCFail.
  simpl...
  intro. intros.
  unfold makeLRuleConstant  in H.
  inversion H...
  + inversion H7...
      inversion H1.
  + inversion H1.
  -
  exists BCAxiom.
  simpl...
  intro. intros.
  unfold makeLRuleConstant  in H.
  inversion H...
  + inversion H7...
      3:{ inversion H2. }
      left. exists N.
      split;intros...
      simpl...
      intros.
      TFocus (makeRRuleConstant TT).
      inversion H2.
      FLLsplit [⌈ t_cons TT ⌉] Delta1.
      simpl...
      right.
      split;intros...
      simpl...
      intros.
       TFocus (makeRRuleConstant TT).
      inversion H4.
      FLLsplit (@nil oo) Delta1.
      simpl...
  + inversion H2...
  -
  exists BCAxiom.
  simpl...
  intro. intros.
  unfold makeLRuleConstant  in H.
  inversion H...
  + inversion H7...
      3:{ inversion H2. }
      left. exists N.
      split;intros...
      simpl...
      intros.
      TFocus (makeLRuleConstant FF).
      inversion H2.
      FLLsplit [⌊ t_cons FF ⌋] Delta1.
      simpl...
      right.
      split;intros...
      simpl...
      intros.
       TFocus (makeLRuleConstant FF).
      inversion H4.
      FLLsplit (@nil oo) Delta1.
      simpl...
  + inversion H2...
  -
  exists BCFail.
  simpl...
  intro. intros.
  unfold makeRRuleConstant  in H.
  inversion H...
  + inversion H7...
      inversion H1.
  + inversion H1.
Qed.    
       
  
(** *** Unary connectives *)

Lemma wellFormedUnary_p : wellFormedUnary.
Proof with sauto. 
  unfold wellFormedUnary;intros.
  destruct lab.
Qed.


(** *** Binary connectives *)
Lemma wellFormedBinary_p : wellFormedBinary.
Proof with sauto.
  unfold wellFormedBinary;intros.
  destruct lab;destruct s.
  +
  exists BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌊ Fo1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleBin AND Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin AND Fo1 Go1 ⌋] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌊ Go1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeLRuleBin AND Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin AND Fo1 Go1 ⌋] Delta1.
    FLLright.
    FLLrelease.
    FLLstore.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌊ Fo1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌊ Go1 ⌋].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.
  +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeRRuleBin AND Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin AND Fo1 Go1 ⌉] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌈ Fo1 ⌉].
    exists [⌈ Go1 ⌉].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11.
    LLExact H10.
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.
  +
  exists BTwoPA.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H9.
    invTri H8.
    invTri H11. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H10.
    LLExact H10.
    apply seqNtoSeq in H9.
    LLExact H9.
    LLExact H10.
    LLExact H9.
    lia.
    intros.
    TFocus ((makeLRuleBin OR Fo1 Go1)).
    inversion H5.
    FLLsplit [⌊ t_bin OR Fo1 Go1 ⌋] Delta12.
    simpl...
    solveLL.
    LLExact H2.
    LLExact H4.
  --
    invTri H8.
    invTri H10.
    invTri H9.
    invTri H12. 
    eexists N.
    exists [⌊ Fo1 ⌋].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11.
    LLExact H11.
    apply seqNtoSeq in H10.
    LLExact H10.
    LLExact H11.
    LLExact H10.
    lia.
    intros.
    simpl... 
    solveLL.
    LLExact H1.
    LLExact H2.    
 + exists BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
  3:{ inversion H2. }
  inversion H6...
    inversion H10...
    exists [⌈ Fo1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLleft...
    apply seqNtoSeq in H6...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleBin OR Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin OR Fo1 Go1 ⌉] Delta1.
    FLLleft.
    FLLrelease.
    FLLstore.
    LLExact H4.

  inversion H6...
    inversion H10... 
    exists [⌈ Go1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    FLLright...
    apply seqNtoSeq in H13...
    LLExact H13.
    lia.
    intros.
    TFocus ((makeRRuleBin OR Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin OR Fo1 Go1 ⌉] Delta1.
    FLLright.
    solveLL.
    LLExact H4.
  - 
  inversion H8...
  3:{ inversion H2. }
  --
    invTri H9.
    invTri H11.
    exists [⌈ Fo1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLleft...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLleft.
    solveLL.
    LLExact H1.
  --
    invTri H9.
    invTri H11.
    exists [⌈ Go1 ⌉].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     right.
    split...
    FLLright...
    solveLL.
    apply seqNtoSeq in H12...
    LLExact H12.
    LLExact H12.
    rewrite H3...
    lia.
    intros.
    FLLright.
    solveLL.
    LLExact H1.
  +
  exists BTwoPM.
  do 3 intro. intros.    
  - 
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  --
    invTri H8.
    invTri H10.
    invTri H11.
    invTri H9.
    invTri H10. 
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    left.
    split...
    rewrite H3...
    rewrite H4...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    apply seqNtoSeq in H11.
    LLExact H11.
    LLExact H12.
    LLExact H11.
    lia.
    intros.
    TFocus ((makeLRuleBin IMP Fo1 Go1)).
    inversion H6.
    FLLsplit [⌊ t_bin IMP Fo1 Go1 ⌋] ( Delta1 ++ Delta2).
    simpl...
    FLLsplit Delta1 Delta2.
    solveLL.
    LLExact H2.
    solveLL.
    LLExact H5.
  --
    invTri H8.
    invTri H11.
    invTri H12.
    invTri H10.
    invTri H11.
    eexists M.
    eexists N0.
    exists [⌈ Fo1 ⌉].
    exists [⌊ Go1 ⌋].
    exists [].
    exists [].
    exists n.
    exists 4.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    right.
    split...
    simpl...
    FLLsplit M N0.
    solveLL.
    apply seqNtoSeq in H13.
    LLExact H13.
    solveLL.
    apply seqNtoSeq in H12.
    LLExact H12.
    LLExact H13.
    LLExact H12.
    lia.
    intros.
    simpl...
    FLLsplit Delta1 Delta2. 
    solveLL.
    LLExact H1.
    solveLL.
    LLExact H2.    
 + exists BOneP.
  do 3 intro. intros.
  inversion H...
  2:{ inversion H2. }
  inversion H7...
  3:{ inversion H2. }
  - 
  inversion H8...
   inversion H9...
  2:{ inversion H11. }
  inversion H10...
    inversion H13...
    exists [⌈ Go1 ⌉;⌊ Fo1 ⌋].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
     left.
    exists N...
    simpl... 
    solveLL.
    apply seqNtoSeq in H15...
    LLExact H15.
    lia.
    intros.
    TFocus ((makeRRuleBin IMP Fo1 Go1)).
    inversion H5.
    FLLsplit [⌈ t_bin IMP Fo1 Go1 ⌉] Delta1.
    simpl...
    solveLL. 
    LLExact H4.
  - 
  inversion H8...
  invTri H10.
   invTri H11.
    invTri H12.
 exists [⌈ Go1 ⌉;⌊ Fo1 ⌋].
    exists [].
    exists n0.
    exists 5.
    split...
    constructor...
    constructor...
    inversion H0...
    inversion H1...
       constructor...
    constructor...
    inversion H0...
    inversion H1... 
     right.
    split...
    simpl...
    solveLL.
    apply seqNtoSeq in H11...
    LLExact H11.
    LLExact H11.
    rewrite H3...
    lia.
    intros.
    simpl...
    solveLL.
    LLExact H1.
 Qed.   
  
Unset Implicit Arguments.
(** *** Quantifiers *)
Lemma wellFormedQuantifier_p : wellFormedQuantifier.
Proof with sauto.
  unfold wellFormedQuantifier. intros.
  destruct lab.
Qed.

Lemma wellFormedTheory_p : wellFormedTheory.
Proof.
  split;[|split;[|split]].
  apply wellFormedConstant. 
  apply wellFormedUnary_p.
  apply wellFormedBinary_p. 
  apply wellFormedQuantifier_p.
Qed.

(** ** Cut-coherency properties *)

(** *** Binary Connectives *)
Lemma CutCoherenceAND: CutCoherenceBin (rulesBC AND).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [perp (up F ) ⊕ perp (up G )]  [perp (down F )] .
  solveLL.
  LFocus (perp (up F ) ⊕ perp (up G )) [⌈ F ⌉].
  solveLL.
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [perp (up F ) ⊕ perp (up G )]  [perp (down G)] .
  solveLL.
  LFocus (perp (up F ) ⊕ perp (up G )) [⌈ G ⌉].
  solveLL.
 Qed.
 
 
Lemma CutCoherenceOR: CutCoherenceBin (rulesBC OR).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [perp (up F )]  [perp (down F) ⊕ perp (down G )]  .
  solveLL.
  solveLL.
  LFocus (perp (down F) ⊕ perp (down G )) [⌊ F ⌋].
  
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [perp (up G )] [perp (down F) ⊕ perp (down G )] .
  solveLL.
  solveLL.
  LFocus (perp (down F ) ⊕ perp (down G )) [⌊ G ⌋].
 Qed.


Lemma CutCoherenceIMP: CutCoherenceBin (rulesBC IMP).
Proof with sauto.
  unfold CutCoherenceBin;intros.
  simpl.
  solveLL.
  TFocus (RCUT F).
  inversion H3.
  eapply ctn with (m:=n)...
  FLLsplit [perp (up F )] [perp (down G ); perp (down F ) ⊗ perp (up G )].
  solveLL.
  solveLL.
  TFocus (RCUT G).
  inversion H3.
  eapply ctn with (m:=m)...
  FLLsplit [⌊ F ⌋; perp (down F ) ⊗ perp (up G )] [perp (down G )].
  solveLL.
  LFocus (perp (down F ) ⊗ perp (up G )) [⌈ G ⌉; ⌊ F ⌋].
  FLLsplit [⌊ F ⌋]  [⌈ G ⌉].
  solveLL.
 Qed.


Lemma CutCoherenceTT: CutCoherenceCte (rulesCTE TT).
Proof with sauto.
  unfold CutCoherenceCte;intros.
  split...
  simpl.
  solveLL.
Qed.

Lemma CutCoherenceFF: CutCoherenceCte (rulesCTE FF).
Proof with sauto.
  unfold CutCoherenceCte;intros.
  split...
  simpl.
  solveLL.
Qed.
  

Lemma CutCoherence_p : CutCoherence .
Proof.
  split;intros. destruct lab.
  apply CutCoherenceTT.
  apply CutCoherenceFF.
  split;intros; try destruct lab.
  split;intros; try destruct lab. 
  apply CutCoherenceAND.
  apply CutCoherenceOR.
  apply CutCoherenceIMP.
Qed.
 
 (** The theory is well formed: cut-coherence holds and all the rules
are bipoles *)
Lemma wellTheory_p : wellTheory.
Proof.
  split.
  exact CutCoherence_p.
  exact wellFormedTheory_p.
Qed. 

Check OLCutElimination wellTheory_p .

(** An inductive definition for LK. This will be used to prove that
the LL encoding is sound and complete *)

Record withcut := { cut : bool }.

Definition nC := {| cut := false |}.
Definition C :=  {| cut := true |}.

Inductive LKSeq P : list uexp -> list uexp -> Prop :=
(* axioms *)
| LKInit : forall F,  LKSeq P [F] [F]
| LKTrue : forall D L, LKSeq P D ((t_cons TT)::L)
| LKFalse : LKSeq P [t_cons FF] [] 

(* conjunction *)
| LKAndL1 : forall D L F G, LKSeq P (F :: D) L -> LKSeq P ( (t_bin AND F G) :: D) L
| LKAndL2 : forall D L F G, LKSeq P (G :: D) L -> LKSeq P ( (t_bin AND F G) :: D) L
| LKAndR : forall D1 D2 L1 L2  F G , LKSeq P D1 (F::L1) -> LKSeq P D2 (G::L2) -> LKSeq P (D1++D2) (t_bin AND F G :: L1++L2)

(* disjunction *)
| LKOrL : forall D1 D2 L1 L2 F G ,  LKSeq P (F :: D1) L1 ->  LKSeq P (G :: D2) L2 -> LKSeq P ( t_bin OR F G :: D1++D2) (L1++L2)
| LKOrR1 : forall D L F G, LKSeq P D (F::L) -> LKSeq P D (t_bin OR F G :: L)
| LKOrR2 : forall D L F G, LKSeq P D (G::L) -> LKSeq P D (t_bin OR F G :: L)

(* implication *)
| LKImpL : forall D1 D2 L1 L2 F G , LKSeq P D1 (F::L1) -> LKSeq P (G::D1) L2 -> LKSeq P (t_bin IMP F G ::D1++D2) (L1++L2)
| LKImpR : forall D L F G, LKSeq P (F::D) (G::L) ->  LKSeq P D (t_bin IMP F G :: L)

(* cut *)
| LKCut {f : cut P = true} : forall D1 D2 L1 L2 F, LKSeq P D1 (F::L1) -> LKSeq P (F::D2) L2 -> LKSeq P (D1++D2) (L1++L2)


(* exchange *)
| LKExL : forall D D' L, Permutation D D' -> LKSeq P D L -> LKSeq P D' L
| LKExR : forall D L L', Permutation L L' -> LKSeq P D L -> LKSeq P D L'

(* contraction *)
| LKCtL : forall D L F, LKSeq P (F :: F :: D)  L -> LKSeq P (F :: D)  L
| LKCtR : forall D L F, LKSeq P D (F :: F :: L)   -> LKSeq P D (F :: L)

(* weakening *)
| LKWkL : forall D L F, LKSeq P D  L -> LKSeq P (F :: D)  L
| LKWkR : forall D L F, LKSeq P D L  -> LKSeq P D (F :: L)
.

#[local] Hint Constructors LKSeq : core .

Global Instance LKL_morph P: 
  Proper ((@Permutation uexp) ==> eq ==> iff) (LKSeq P).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExL;eauto.
  apply Permutation_sym in H.
  eapply LKExL;eauto.
Qed.

Global Instance LKR_morph P : 
  Proper (eq ==> (@Permutation uexp)  ==> iff) (LKSeq P).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExR;eauto.
  apply Permutation_sym in H0.
  eapply LKExR;eauto.
Qed.



(* 
Ltac solveOLTheory :=
  try
    match goal with
    | [|- OLTheory _] =>
      first [ apply ooth_init ; auto ; SolveIS
            | do 2 constructor;auto ; SolveIS ]
    end.
 *)
    
(* Ltac toLK H :=
  match (type of H) with
  | In (u| _ |)(LEncode _ ++ REncode _) =>
    apply upRight in H; apply OLInPermutation in H;CleanContext;
    eapply LKExR; [apply Permutation_sym; eauto|]
  | In (d| _ |)(LEncode _ ++ REncode _) =>
    apply downLeft in H; apply OLInPermutationL in H;CleanContext;
    eapply LKExL; [apply Permutation_sym;eauto | ]
  | seqN _ _ (u| ?F | :: LEncode ?L ++ REncode ?R) [] (> []) =>
    apply exchangeCCN with (CC' := LEncode L ++ REncode (F :: R)) in H ;[| simpl; perm]
  | seqN _ _ (u| ?F | :: ?T :: LEncode ?L ++ REncode ?R) [] (> []) =>
    apply exchangeCCN with (CC' := T :: LEncode L ++ REncode (F :: R)) in H ;[| simpl; perm]
  | seqN _ _ (d| ?F | :: LEncode ?L ++ REncode ?R) [] (> []) =>
    apply exchangeCCN with (CC' := LEncode (F :: L) ++ REncode R) in H ;[| simpl; perm]
  | seqN _ _ (d| ?F | :: ?T :: LEncode ?L ++ REncode ?R) [] (> []) =>
    apply exchangeCCN with (CC' := T :: LEncode (F::L) ++ REncode R) in H ;[| simpl; perm]
  end. *)

Theorem soundeness_aux: forall L L', LKSeq nC L L' ->
                                 isOLFormulaL L ->
                                 isOLFormulaL L' ->
                                 seq (OLTheory PN) (LEncode L ++  REncode L') [] (UP []).
Proof with sauto;solveLL.
  intros.
  induction H...
  + (* init *)
    TFocus (RINIT F)...
    inversion H.
    apply ooth_init...
    inversion H1...
    FLLsplit. 
    all:simpl...
    intuition.
  + (* True on the right *)
    TFocus(makeRRuleConstant TT)...
    inversion H.
    constructor.
    constructor.
    OLSolve.
    FLLsplit. 
    all:simpl...
  + (* false on the left *)
    TFocus(makeLRuleConstant FF)...
    inversion H.
    constructor.
    constructor.
    OLSolve.
    FLLsplit. 
    all:simpl...
  + (* ANDL1 *)
    TFocus (makeLRuleBin AND F G)...
    inversion H2.
    constructor.
    constructor.
    inversion H0...
    FLLsplit.
    all:simpl...
    FLLleft...
    apply weakening.
    PosNeg.
    admit.
    simpl in IHLKSeq.
    LLPerm (⌊ F ⌋ :: ⌞ D ⌟ ++ ⌜ L ⌝). 
    apply IHLKSeq...
    admit.
  + (* ANDL2 *)
    TFocus (makeLRuleBin AND F G)...
    inversion H2.
    constructor.
    constructor.
    inversion H0...
    FLLsplit.
    all:simpl...
    FLLright...
    apply weakening.
    PosNeg.
    admit.
    simpl in IHLKSeq.
    LLPerm (⌊ G ⌋ :: ⌞ D ⌟ ++ ⌜ L ⌝). 
    apply IHLKSeq...
    admit. 
 + (* And R *)
    TFocus (makeRRuleBin AND F G)...
    inversion H3.
    constructor.
    constructor.
    inversion H1...
    FLLsplit. 
    all: simpl...
    apply weakening_middle.
    simpl in IHLKSeq1.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌞ D1 ⌟ ++ ⌈ F ⌉ ::  ⌜ L1 ⌝) ++ ⌞ D2 ⌟ ++ ⌜ L2 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq1...
    admit. admit.
    apply weakening_middle.
    simpl in IHLKSeq2.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌞ D2 ⌟ ++ ⌈ G ⌉ ::  ⌜ L2 ⌝) ++ ⌞ D1 ⌟ ++ ⌜ L1 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq2...
    admit. admit.    
  + (* Or L *)
    TFocus (makeLRuleBin OR F G)...
    inversion H3.
    constructor.
    constructor.
    inversion H0...
    FLLsplit. 
    all: simpl...
    apply weakening. 
    simpl in IHLKSeq1.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌊ F ⌋ :: ⌞ D1 ⌟ ++ ⌜ L1 ⌝) ++ ⌞ D2 ⌟ ++ ⌜ L2 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq1...
    admit. admit.
    apply weakening.
    simpl in IHLKSeq2.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌊ G ⌋ :: ⌞ D2 ⌟ ++ ⌜ L2 ⌝) ++ ⌞ D1 ⌟ ++ ⌜ L1 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq2...
    admit. admit.
  + (* ORR1 *)
    TFocus (makeRRuleBin OR F G)...
    inversion H2.
    constructor.
    constructor.
    inversion H1...
    FLLsplit.
    all:simpl...
    FLLleft...
    apply weakening_middle.
    PosNeg.
    admit.
    simpl in IHLKSeq.
    LLPerm (⌞ D ⌟ ++ ⌈ F ⌉ :: ⌜ L ⌝). 
    apply IHLKSeq...
    admit.
  + (* ANDL2 *)
    TFocus (makeRRuleBin OR F G)...
    inversion H2.
    constructor.
    constructor.
    inversion H1...
    FLLsplit.
    all:simpl...
    FLLright...
    apply weakening_middle.
    PosNeg.
    admit.
    simpl in IHLKSeq.
    LLPerm (⌞ D ⌟ ++ ⌈ G ⌉ :: ⌜ L ⌝). 
    apply IHLKSeq...
    admit. 
  + (* ImpL *)
    TFocus (makeLRuleBin IMP F G)...
    inversion H3.
    constructor.
    constructor.
    inversion H0...
    FLLsplit. 
    all: simpl...
    FLLsplit. 
    all: simpl...
    all: apply weakening. 
    simpl in IHLKSeq1.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌞ D1 ⌟ ++ ⌈ F ⌉ ::  ⌜ L1 ⌝) ++ ⌞ D2 ⌟ ++ ⌜ L2 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq1...
    admit. admit.
    simpl in IHLKSeq2.
    rewrite REncodeApp, LEncodeApp.
    PosNeg. admit.
    LLPerm ((⌊ G ⌋ :: ⌞ D1 ⌟ ++ ⌜ L2 ⌝) ++ ⌞ D2 ⌟ ++ ⌜ L1 ⌝).
    apply weakeningGen_rev.
    apply IHLKSeq2...
    admit. admit.
  + (* ImpR *)
    TFocus (makeRRuleBin IMP F G)...
    inversion H2.
    constructor.
    constructor.
    inversion H1...
    FLLsplit. 
    all: simpl...
    apply weakening_middle. 
    simpl in IHLKSeq.
    PosNeg. admit.
    PosNeg. admit.
    LLPerm (⌊ F ⌋ :: ⌞ D ⌟ ++ ⌈ G ⌉ :: ⌜ L ⌝).
    apply IHLKSeq...
    admit. admit.
  + (* exchange *)
    eapply Permutation_map in  H as H'.
    unfold LEncode; rewrite <- H'...
    apply IHLKSeq...
    rewrite H...
  + eapply Permutation_map in  H as H'.
    unfold REncode; rewrite <- H'...
    apply IHLKSeq...
    rewrite H...
  + (* contraction *)
    simpl.
    simpl in IHLKSeq.
    apply contraction. 
    apply IHLKSeq...
    admit.
  + 
     simpl.
    simpl in IHLKSeq.
    apply contraction_middle. 
    apply IHLKSeq...
    admit. 
  + (* weakening *)
    simpl.
    apply weakening. 
    apply IHLKSeq...
    admit.
  + 
     simpl.
    apply weakening_middle. 
    apply IHLKSeq...
    admit.
Admitted.         
  

Theorem Soundeness: forall L L' D D', 
      isOLFormulaL L ->
      isOLFormulaL L' ->
      isOLFormulaL D ->
      isOLFormulaL D' ->
      LKSeq nC (L++D) (L'++D') ->
      seq (OLTheory PN) (LEncode L++ REncode L') (LEncode D ++ REncode D') (UP []).
Proof with sauto.
  intros *.
  intros isFL isFL' isFD isFD' HLK.
  PosNegAll...
  admit.
  eapply soundeness_aux in HLK...
  rewrite  LEncodeApp, REncodeApp in HLK.
  LLPerm ((⌞ L ⌟ ++ ⌞ D ⌟) ++ ⌜ L' ⌝ ++ ⌜ D' ⌝)...
  OLSolve.
  OLSolve.
Admitted.      

Definition HypComp n :=
forall m L L' D D',
    m < n ->
    isOLFormulaL L ->
    isOLFormulaL L' ->
    isOLFormulaL D ->
    isOLFormulaL D' ->
    seqN (OLTheory PN) m (⌞ L ⌟ ++ ⌜ L' ⌝)
      (⌞ D ⌟ ++ ⌜ D' ⌝) (UP []) ->
    LKSeq nC (L ++ D) (L' ++ D').
 
   (** Completeness theorem *)
Theorem Completeness: forall n L D, 
    isOLFormulaL L ->
    isOLFormulaL D ->
    seqN (OLTheory PN) n (LEncode L ++ REncode D) [] (UP []) ->
    LKSeq nC L D .
Proof with sauto;solveLL.
  induction n using lt_wf_ind; intros *.  
  intros HisL HisD Hseq. 
  inversion Hseq... 
  2:{ inversion H1...
        inversion H3...
        ++ (* Constant right *)
      apply FocusingClause in H2...
      apply upRight in H7.
      apply OLInPermutation in H7...
      rewrite H7...
      destruct C0...
      inversion H8...
      inversion H5.
      
    ++ (* constant left *)
      apply FocusingClause in H2...
      apply downLeft in H7.
      apply OLInPermutationL in H7...
      rewrite H7...
      destruct C0...
      inversion H8...
      inversion H5.
      admit.
   ++ (* Constant right *)
      apply FocusingClause in H2...
      apply upRight in H7.
      apply OLInPermutation in H7...
      rewrite H7...
      destruct C0...
   ++ (* Constant right *)
      apply FocusingClause in H2...
      apply downLeft in H7.
      apply OLInPermutationL in H7...
      rewrite H7...
      destruct C0...
   ++ (* Constant right *)
      apply FocusingClause in H2...
      apply upRight in H7.
      apply OLInPermutation in H7...
      rewrite H7...
      destruct C0...
      { (* AND *) 
          inversion H8...
          inversion H11...
          
          
       }
   ++ (* Constant right *)
      apply FocusingClause in H2...
      apply downLeft in H7.
      apply OLInPermutationL in H7...
      rewrite H7...
      destruct C...
      
      
      
      
      inversion H8...
      inversion H5.
      
    ++ (* constant left *)
      apply FocusingClause in H2...
      apply downLeft in H7.
      apply OLInPermutationL in H7...
      rewrite H7...
      destruct C...
      inversion H8...
      inversion H5.
      admit.      
      
      
      -
      apply downLeft in H6.
         
  (** Completeness theorem *)
Theorem Completeness: forall n L L' D D', 
    isOLFormulaL L ->
    isOLFormulaL L' ->
    isOLFormulaL D ->
    isOLFormulaL D' ->
    seqN (OLTheory PN) n (LEncode L ++ REncode L') (LEncode D ++  REncode D') (UP []) ->
    LKSeq (L++D) (L'++D') .
Proof with sauto;solveLL.
  induction n using lt_wf_ind; intros *.  
  intros HisL HisL' HisD HisD' Hseq. 
  assert(HypComp n).
  unfold HypComp.
  intros.
  revert H5.
  apply H...
  clear H. rename H0 into HI.
  inversion Hseq...
  3:{ 
     inversion H0...
  + inversion H2...
  ++ (* Constant right *)
      apply FocusingClause in H1...
      -
      apply checkEncodeCasesU in H6... 
      apply OLInPermutation' in H1...
      rewrite H1...
      rewrite <- perm_takeit_2...
      destruct C...
      inversion H7...
      inversion H6.
      -
      apply upRight in H6.
      apply OLInPermutation in H6...
      rewrite H6...
      rewrite <- app_comm_cons...
      destruct C...
      inversion H7...
      inversion H4.
    ++ (* constant left *)
      apply FocusingClause in H1...
      -
      apply checkEncodeCasesD in H6...
      apply OLInPermutationL' in H1...
      rewrite H1...
      rewrite <- perm_takeit_2...
      destruct C...
      inversion H7...
      inversion H6.
      admit.
      -
      apply downLeft in H6.
      apply OLInPermutationL in H6...
      rewrite H6...
      rewrite <- app_comm_cons...
      destruct C...
      inversion H7...
      inversion H4. 
      admit.
    ++ (* unary right *)
    destruct C. 
     ++ (* unary left *)
    destruct C.
  ++  (* binary right *) 
     apply FocusingClause in H1...
      -
      apply checkEncodeCasesU in H6... 
      apply OLInPermutation' in H1...
      rewrite H1...
      rewrite <- perm_takeit_2...
      destruct C...
      { (* AND *)
        inversion H7...
        inversion H11...
        apply LKAndR...
         apply upRight in H6.
      apply OLInPermutation in H6...
      rewrite H6...
      rewrite <- app_comm_cons...
      destruct C...
      inversion H7...
      inversion H4.
    ++ (* constant left *)
      apply FocusingClause in H1...
      -
      apply checkEncodeCasesD in H6...
      apply OLInPermutationL' in H1...
      rewrite H1...
      rewrite <- perm_takeit_2...
      destruct C...
      inversion H7...
      inversion H6.
      admit.
      -
      apply downLeft in H6.
      apply OLInPermutationL in H6...
      rewrite H6...
      rewrite <- app_comm_cons...
      destruct C...
      inversion H7...
      inversion H4. 
      admit.     
     
     
     
     
      - simpl in H7.  
         inversion H7...
      - simpl in H7.  
         inversion H7...
  ++ (* Constant right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8... 
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      -
      simpl in H9.
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- app_comm_cons...
         
  + inversion H0... 
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply FocusingWith in H7...
      apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndR...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H10.
        rewrite <- H6...
       -
      apply FocusingWith in H7...
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      apply LKAndR.
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      LLExact H8.
      simpl...
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      LLExact H10.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
     apply FocusingPlus in H7...
      rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndL1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
        
      rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndL2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5 in HisL.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPlus in H7...
      
      apply LKAndL1.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      
      apply LKAndL2.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
     apply FocusingPlus in H7...
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrR1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
        
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrR2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPlus in H7...
      
      apply LKOrR1.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
      apply LKOrR2.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply FocusingWith in H7...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrL...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H10.
        rewrite <- H6...
       -
      apply FocusingWith in H7...
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5 in HisL.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      apply LKOrL.
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...

    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
     apply FocusingPar in H7...
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKImpR...
        
      do  2 rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPar in H7...
      apply LKImpR...
      
      do 2 rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
    
       apply FocusingTensor in H7...
       rewrite H9 in H6.
       apply destructEncode in H6...
       assert(LKSeq (L++x) (L'++F0 :: x5)).
        eapply H with (m:=x2) (a:=a)...
        assert(isOLFormulaL x1) by OLSolve.
        OLSolve.
      LLExact H8.
      rewrite H6...
      assert(LKSeq (L++G :: x6) (L'++x7)).
        eapply H with (m:=x2) (a:=a)...
         assert(isOLFormulaL x1) by OLSolve.
        OLSolve.
      LLExact H11.
      rewrite H10...
      assert(LKSeq (t_bin IMP F0 G :: (L++x) ++ (L++x6)) ((L'++x5) ++ (L' ++ x7))).
      apply LKImpL...
      rewrite <- Permutation_midle...
      rewrite <- Permutation_midle...
      rewrite <- Permutation_midle...
      apply LKCtLGen.
      apply LKCtRGen.
      eapply LKExR with (L:=(L' ++ x5) ++ L' ++ x7)...
      rewrite H13...
      eapply LKExL with (L:=t_bin IMP_BODY.(con) F0 G :: (L ++ x) ++ L ++ x6)...
      rewrite H7...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisL.
      rewrite H5...
      
      rewrite <- app_comm_cons.
      
       apply FocusingTensor in H7...
       apply destructEncode in H10...
       assert(LKSeq (L++x) (L'++F0 :: x6)).
        eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      rewrite H7...
      assert(LKSeq (L++G :: x7) (L'++x8)).
        eapply H with (m:=x3) (a:=a)...
      LLExact H12.
      rewrite H11...
      
      assert(LKSeq (t_bin IMP F0 G :: (L++x) ++ (L++x7)) ((L'++x6) ++ (L' ++ x8))).
      apply LKImpL...
      1-2: rewrite <- Permutation_midle...
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      rewrite <- Permutation_midle...
      apply LKCtLGen.
      apply LKCtRGen.
      eapply LKExR with (L:=(L' ++ x6) ++ L' ++ x8)...
      rewrite H14...
      eapply LKExL with (L:=t_bin IMP_BODY.(con) F0 G :: (L ++ x) ++ L ++ x7)...
      rewrite H10...
   + apply FocusingInitRuleU in H3;sauto.
    ++   
      change [u| OO |; d| OO |] with ([u| OO |] ++ [d| OO |]) in H4. 
      apply destructEncode in H4...
      apply map_eq_cons in H9...
      apply map_eq_cons in H9...
      apply map_eq_cons in H10...
      apply map_eq_cons in H7...
      apply map_eq_nil in H9...
      apply map_eq_nil in H6...
      inversion H11... inversion H10...
      
      rewrite Permutation_app_comm.
      simpl.
      rewrite Permutation_app_comm.
      simpl... apply InitGen...
      
      apply map_eq_cons in H7...
      apply map_eq_cons in H6...
   ++  CleanContext.
        apply map_eq_cons in H8...
        apply map_eq_nil in H5...
        inversion H9...
        
        apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesD in H6...
      apply OLInPermutationL' in H4...
      rewrite Permutation_app_comm.
      rewrite H4;simpl... apply InitGen...
    ++ apply map_eq_cons in H5...
    ++ apply map_eq_cons in H8...
    ++  CleanContext.
        apply map_eq_cons in H5...
        apply map_eq_nil in H8...
        inversion H9...
        
        apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesU in H6...
      apply OLInPermutation' in H4...
      rewrite Permutation_app_comm.
      rewrite H4;simpl...
      apply InitGen...
     ++ 
      apply map_eq_nil in H3, H8...
         apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesU in H6...
      
         apply PermSecond in H4.
      rewrite !secondApp in H4.
      rewrite !secCEncode in H4.
      simpl in H4...
      symmetry in H4.
      apply checkEncodeCasesD in H4...
      
      apply OLInPermutationL' in H4...
     apply OLInPermutation' in H6...
     rewrite H6, H4...
     apply InitGen...
    + inversion H0... 
    ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H6...
      rewrite H6...
      rewrite Permutation_midle...
      apply LKAllR; intros...
       apply FocusingForallUP with (y:=x2) in H8...
       
      rewrite H6 in HisD'.
      rewrite <- Permutation_midle...
      eapply H with (m:=x3) (a:=a)...
       solveQF. 
        LLExact H10.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesU in H10...
      apply OLInPermutation' in H6...
      rewrite H6 in HisL'.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply LKAllR;intros...
      apply FocusingForallUP with (y:=x3) in H8...
      rewrite <- Permutation_midle.
      eapply H with (m:=x4) (a:=a)...
      solveQF.
      LLExact H11.
      simpl...
    ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H6...
      rewrite H6...
      rewrite Permutation_midle...
       apply FocusingExistsDW in H8...
      apply LKAllL with (t:=x3)... 
      rewrite H6 in HisD.
      rewrite <- Permutation_midle...
      eapply H with (m:=x2) (a:=a)...
       solveQF. 
        LLExact H11.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesD in H10...
      apply OLInPermutationL' in H6...
      rewrite H6 in HisL.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply FocusingExistsDW in H8...
      
      apply LKAllL with (t:=x4);intros...
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      solveQF.
 ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H6...
      rewrite H6...
      rewrite Permutation_midle...
       apply FocusingExistsUP in H8...
      apply LKSomeR with (t:=x3); intros... 
      rewrite H6 in HisD'.
      rewrite <- Permutation_midle...
      eapply H with (m:=x2) (a:=a)...
       solveQF. 
        LLExact H11.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesU in H10...
      apply OLInPermutation' in H6...
      rewrite H6 in HisL'.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply FocusingExistsUP in H8...
      
      apply LKSomeR with (t:=x4);intros...
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      solveQF.
      
      LLExact H12.
      simpl...
       ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H6...
      rewrite H6...
      rewrite Permutation_midle...
      apply LKSomeL; intros...
       apply FocusingForallDW with (y:=x2) in H8...
       
      rewrite H6 in HisD.
      rewrite <- Permutation_midle...
      eapply H with (m:=x3) (a:=a)...
       solveQF. 
        LLExact H10.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesD in H10...
      apply OLInPermutationL' in H6...
      rewrite H6 in HisL.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply LKSomeL;intros...
      apply FocusingForallDW with (y:=x3) in H8...
      rewrite <- Permutation_midle.
      eapply H with (m:=x4) (a:=a)...
      solveQF.
  + apply BipoleReasoning in H3...
     ++  
        apply FocusingQuest in H6...
        apply checkEncodeCasesD in H7... 
        apply OLInPermutationL' in H3...
        rewrite H3.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (m:=x1) (a:=a)...
        LLExact H5.
    ++ 
      apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8...
      symmetry in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H3...
      
      rewrite H3...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H3...
        apply FocusingQuest in H6...
      rewrite app_comm_cons.
        eapply H with (m:=x3) (a:=a)...
  + apply BipoleReasoning in H3...
     ++  
        apply FocusingQuest in H6...
        apply checkEncodeCasesU in H7... 
        apply OLInPermutation' in H3...
        rewrite H3.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (m:=x1) (a:=a)...
        LLExact H5. simpl...
    ++ 
      apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8...
      symmetry in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H3...
      
      rewrite H3...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H3...
        apply FocusingQuest in H6...
      rewrite app_comm_cons.
        eapply H with (m:=x3) (a:=a)...
   
        LLExact H8. simpl...
    * solveSignature1.
Qed.
     
 Inductive buildLKTheory  : oo ->  Prop :=
  | bcteRT : isOLFormula (t_cons TT) -> buildLKTheory (makeRRuleConstant TT) 
  | bcteLT : isOLFormula (t_cons TT) -> buildLKTheory (makeLRuleConstant TT) 
  | bcteRF : isOLFormula (t_cons FF) -> buildLKTheory (makeRRuleConstant FF) 
  | bcteLF : isOLFormula (t_cons FF) -> buildLKTheory (makeLRuleConstant FF)   
  
  | ANDR : forall F G, isOLFormula ( t_bin AND F G) -> buildLKTheory  (makeRRuleBin AND F G)
  | ANDL : forall F G, isOLFormula ( t_bin AND F G) -> buildLKTheory  (makeLRuleBin AND F G)
  | ORR : forall F G, isOLFormula ( t_bin OR F G) -> buildLKTheory  (makeRRuleBin OR F G)
  | ORL : forall F G, isOLFormula ( t_bin OR F G) -> buildLKTheory  (makeLRuleBin OR F G)
  | IMPR : forall F G, isOLFormula ( t_bin IMP F G) -> buildLKTheory  (makeRRuleBin IMP F G)
  | IMPL : forall F G, isOLFormula ( t_bin IMP F G) -> buildLKTheory  (makeLRuleBin IMP F G).
  
  
Inductive LKTheory : oo -> Prop :=
  | lk_rules : forall OO, buildLKTheory OO ->  LKTheory OO
  | lk_init : forall OO, isOLFormula OO -> LKTheory (RINIT OO) 
  | lk_pos : forall OO, isOLFormula OO -> LKTheory (POS OO) 
  | lk_neg : forall OO, isOLFormula OO -> LKTheory (NEG OO) .
  
  
  Inductive LKTheoryCut (n:nat) : oo -> Prop :=
  | lkc_rules : forall OO, LKTheory OO ->  LKTheoryCut n OO
  | lkc_cut : forall OO, CutRuleN n OO -> LKTheoryCut n OO. 
  
 Lemma  LKtoLKC n Rule: LKTheory Rule -> LKTheoryCut n Rule.
 Proof with sauto.
 intros.
 inversion H...
 apply lkc_rules ...
 apply lkc_rules ...
 apply lkc_rules ...
 apply lkc_rules ...
 Qed.
 
 Lemma LKtoOL Rule: LKTheory Rule -> OLTheory PN Rule.
 Proof with sauto.
 intros.
 inversion H...
 inversion H0...
   all: try solve [constructor;constructor;auto].
 Qed.  
 
 Check OLCutElimination.
Check OLCutElimination wellTheory_p .
 
  Lemma LKCtoOLC n Rule: LKTheoryCut n Rule -> OLTheoryCut PN n Rule.
 Proof with sauto.
 intros.
 inversion H...
 inversion H0...
 inversion H1...
 all: try solve [constructor;constructor;auto].
 Qed.
 
 
     Variable LKSeq LKSeqC: list uexp -> list uexp -> Prop. 
Notation "'(' th ')' ⊢ B ';' L ⇑ F " := (seq th B L (UP F))  (at level 80).
 
Theorem AdequacyLK:  forall L L' D D', 
   LKSeq (L ++ D) (L' ++ D') <->
    seq (LKTheory)
         (LEncode L ++ REncode L')
         (LEncode D ++ REncode D') (UP []).
Proof with sauto.   
    intros.
    Admitted.

Theorem AdequacyLK':  forall L L' D D', 
   LKSeqC (L ++ D) (L' ++ D') <->
   exists n, seq (LKTheoryCut n)
         (LEncode L ++ REncode L')
         (LEncode D ++ REncode D') (UP []).
Proof with sauto.   
    intros.
    Admitted.
  
    
 Lemma asas A B C D : LKSeqC (A++B) (C++D) -> LKSeq (A++B) (C++D).
 Proof with sauto.
 intros.
 apply AdequacyLK' in H...
 generalize (OLCutElimination wellTheory_p);intros.
 apply AdequacyLK...
 
 Check OLCutElimination.
 
    assert(exists n, (OLTheoryCut PN n)⊢ ⌞ A ⌟ ++ ⌜ C ⌝; ⌞ B ⌟ ++ ⌜ D ⌝ ⇑ []). admit.
      destruct H1.
      apply H0 in H1.
      apply AdequacyLK...
      5:{
      inversion H1...
      3:{ inversion H3...
            inversion H5...
       generalize wellFormedTheory_p.
          intros.
          destruct H2. 
      
        


