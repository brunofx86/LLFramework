(** * System LM for propositional multiplicative and additive linear logic

This file encodes the inference rules of the system LM (two sided)
of propositional multiplicative additive linear logic.
 *)

Require Import LL.Misc.Permutations.
Require Import LL.Framework.SL.FLL.Specifications.Intuitionistic.LM.Cut.

Set Implicit Arguments.

(** ** Adequacy 

Now we prove that the encoding is sound and complete. For that, we
define the provability relation of LM as an inductive definition *)

Notation "F ∧' G" := (t_bcon AND F G) (at level 10) .
Notation "F ∨' G" := (t_bcon OR F G) (at level 10) .
Notation "F ⇒' G" := (t_bcon IMP F G) (at level 10) .

Record cutrule := {
  cut : bool   }.

Inductive LMSeq {P} {n} : list uexp -> uexp -> Prop :=
| LMTRUE : forall L, LMSeq L (t_ccon TT)
| LMFALSE : forall L C, LMSeq (t_ccon FF :: L) C 
| LMInit : forall F , LMSeq [F] F
| LMAndR : forall L F G, LMSeq L F -> LMSeq L G -> LMSeq  L (F ∧' G)
| LMAndL1 : forall L C F G, LMSeq (F :: L) C -> LMSeq (F ∧' G :: L) C
| LMAndL2 : forall L C F G, LMSeq (G :: L) C -> LMSeq (F ∧' G :: L) C
| LMOrR1 : forall L F G, LMSeq L F -> LMSeq L (F ∨' G)
| LMOrR2 : forall L F G, LMSeq L G -> LMSeq L (F ∨' G)
| LMOrL : forall L C F G, LMSeq (F ::L) C -> LMSeq (G ::L) C -> LMSeq (F ∨' G :: L) C
| LMImpR : forall L F G, LMSeq (F::L) G -> LMSeq  L (F ⇒' G)
| LMImpL : forall L1 L2 C F G, LMSeq L1 F -> LMSeq (G::L2) C -> LMSeq (F ⇒' G :: L1++L2) C
| LMExL : forall  L1 C L1', Permutation L1 L1' -> LMSeq L1' C -> LMSeq L1 C

| LMWL : forall  L C F, LMSeq L C -> LMSeq (F::L) C
| LMCL : forall  L C F, LMSeq (F::F::L) C -> LMSeq (F::L) C

| LMCut {f : cut P = true}: forall F L1 L2 C, 
        lengthUexp F n ->  isOLFormula F -> LMSeq (F::L1) C -> LMSeq L2 F -> LMSeq (L1++L2) C.

Definition wc := {| cut:= true |}. (* with cut *)
Definition wnc :=  {| cut:= false |}. (* with no cut *)


Global Instance LML_morph w n: 
  Proper ((@Permutation uexp) ==> eq ==> iff) (LMSeq (P:=w) (n:=n)).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LMExL with (L1':=x);auto.
  eapply LMExL with (L1':=y);auto. 
Qed.

Local Hint Constructors LMSeq : core.

Ltac LMExact H :=
  let G:= type of H in
  match G with
  | (LMSeq ?L ?R) =>
    match goal with
    | [ |- LMSeq ?L' ?R ] =>
      apply LMExL with (L1':= L);[ 
           try perm | auto ]
    end
  end;auto.

Lemma GenLMCL : forall  w n L C L1, LMSeq (P:=w) (n:=n)  (L1++L1++L) C -> LMSeq (P:=w) (n:=n) (L1++L) C.
Proof with sauto.
 intros. revert dependent L. induction L1; intros *...
 intro H. 
 eapply LMExL with (L1:= L1++ L1 ++ a::a::L) in H...
 apply IHL1 in H.
 rewrite <- app_comm_cons. 
 apply LMCL. LMExact H.   
Qed.

Lemma GenLMCL_rev : forall  w n L C L1, LMSeq (P:=w) (n:=n)  (L++L1++L1) C -> LMSeq (P:=w) (n:=n) (L++L1) C.
Proof with sauto.
 intros. rewrite Permutation_app_comm.
 apply GenLMCL. LMExact H.

Qed.

Lemma GenLMWL : forall  w n L C L1, LMSeq (P:=w) (n:=n)  L C -> LMSeq (P:=w) (n:=n) (L1++L) C.
Proof with sauto.
 intros. revert dependent L. induction L1; intros *...
 intro H. 
 eapply LMExL with (L1':= L1 ++ a::L)... 
Qed.

Lemma GenLMWL_rev : forall  w n L C L1, LMSeq (P:=w) (n:=n)  L C -> LMSeq (P:=w) (n:=n) (L++L1) C.
Proof with sauto.
 intros. rewrite Permutation_app_comm.
 apply GenLMWL. LMExact H.

Qed.

(** LM -> LM+CUT *)
Theorem SoundnessLM: forall n L1 L2, 
                   LMSeq (P:=wnc) (n:=n) L1 L2 -> LMSeq (P:=wc) (n:=n) L1 L2.
Proof with sauto. 
    intros *. 
    intros HM.
   induction HM;simpl...
   rewrite H...
Qed.

Require Import LL.Framework.SL.FLL.InvPositivePhase.
 
Lemma BangCon':
  forall {OLS : OLSig} [th : oo -> Prop] [n : nat] 
    [F : oo] [Gamma Delta : list oo] [X : Arrow],
  posLFormula F ->
  FLLS th Gamma (! F :: Delta) X ->
  FLLS th Gamma (F :: Delta) X.
Proof with sauto.
  intros.
  apply FLLStoFLLN in H0...
  apply BangCon in H0...
Qed.

(** LM -> LL (LM) *)
Theorem SoundenessFLL: forall n L C, 
                            isOLFormulaL L ->
                                isOLFormula C ->
                  LMSeq (P:=wnc) (n:=n) L C ->
                                FLLS (OLTheory PnN) (LEncode L)  [⌈C⌉] (UP []).
Proof with sauto; try OLSolve;try solveLL. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
   + LLtheory (makeRRuleC TT).
      LLtensor [⌈ t_ccon TT ⌉] (@nil oo)... 
      simpl. solveLL.
   + LLtheory (makeLRuleC FF).
      LLtensor (@nil oo) [⌈ C ⌉]... 
      simpl. solveLL.
  + LLtheory (RINIT F).
      inversion H.
     LLtensor [⌈ F ⌉] (@nil oo) ;solveLL.
  + LLtheory (makeRRuleB AND F G). 
     LLtensor [⌈ F ∧'  G ⌉] (@nil oo) ;solveLL.
     simpl. solveLL.
     1-2: LLfocus1...
     apply IHHM1...
    inversion isFL2...
    inversion H...
    apply IHHM2...
    inversion isFL2...
    inversion H...
  + simpl in IHHM...
     LLtheory (makeLRuleB AND F G). 
    apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo) [⌈ C ⌉] ;solveLL.
   simpl;solveLL.
    LLleft. solveLL. apply weakening...
   PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ F ⌋::LEncode L).
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     LLtheory (makeLRuleB AND F G). 
    apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
   simpl;solveLL.
    LLright. solveLL.
apply weakening...
   PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ G ⌋::LEncode L).

   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     LLtheory (makeRRuleB OR F G). 
     LLtensor [⌈ F ∨' G ⌉ ] (@nil oo) ;solveLL.
   simpl;solveLL.
    LLleft. solveLL. 
   apply IHHM...
   inversion isFL2...
  inversion H...
  + simpl in IHHM...
     LLtheory (makeRRuleB OR F G). 
     LLtensor [⌈ F ∨' G ⌉ ] (@nil oo) ;solveLL.
   simpl;solveLL.
    LLright. solveLL.
   apply IHHM...
   inversion isFL2...
  inversion H...
  + simpl in IHHM1,IHHM2...
     LLtheory (makeLRuleB OR F G). 
    apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo) [⌈ C ⌉] ;solveLL.
   simpl. solveLL.
  1-2: apply weakening...
  1-2: PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ F ⌋::LEncode L).

   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   inversion isFL1...
  inversion H1...
  inversion H...

   LLPerm(⌊ G ⌋::LEncode L).
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
 + simpl in IHHM...
     LLtheory (makeRRuleB IMP F G). 
     LLtensor [⌈ F ⇒' G ⌉] (@nil oo) ;solveLL.
   simpl. solveLL.
   LLPerm([⌊ F ⌋ ; ! ⌈ G ⌉]).
   PosNeg... 
   inversion isFL2...
  inversion H...
   LLPerm(⌊ F ⌋::LEncode L).
   LLfocus1...
   apply IHHM...
   inversion isFL2...
  inversion H...
   inversion isFL2...
  inversion H...
  + simpl in IHHM1,IHHM2...
     LLtheory (makeLRuleB IMP F G). 
    apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
   simpl. 
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
    1-2:apply weakening...
     rewrite LEncodeApp. 
     apply weakeningGen_rev.
   apply IHHM1...
   inversion isFL1...
  inversion isFL1...
  inversion H1...
  inversion H...
     rewrite LEncodeApp. 
     apply weakeningGen.
    PosNeg...
   inversion isFL1...
  inversion H1...
  inversion H...
  LLPerm(⌊ G ⌋::LEncode L2).

   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H. apply IHHM...
  +  LLtheory (POS F )... inversion H. 
       apply ooth_strpos.
    constructor. inversion isFL1...
      LLtensor (@nil oo) [⌈ C ⌉];solveLL.
      apply weakeningGen_rev.
     apply weakening.
     apply IHHM...
  +  LLtheory (POS F ). inversion H. 
       apply ooth_strpos.
    constructor. inversion isFL1...
      LLtensor (@nil oo) [⌈ C ⌉];solveLL.
      simpl in IHHM...
      LLPerm (⌊ F ⌋ :: ⌊ F ⌋ :: ⌞ L ⌟).
      apply IHHM...
      inversion isFL1...
Qed.

Require Import LL.Framework.SL.FLL.Reasoning.
  

Ltac LMPerm LI :=
  match goal with
  | [ |- LMSeq _ _ ] =>
          first[ apply LMExL with (L1' := LI);[perm|]
               | auto]
end.


(** LL (LM) -> LM  *)
Theorem CompletenessFLL: forall x n L R D, 
        isOLFormulaL L->
        isOLFormulaL R ->  isOLFormula D ->                      
   FLLN (OLTheory PnN) x (LEncode R)  (⌈D⌉:: (LEncode L) ) (UP []) ->
                 LMSeq (P:=wnc) (n:=n) (L++R) D.
Proof with sauto;try solveLL; try OLSolve.
  induction x using lt_wf_ind; intros *.  
  intros HisL HisR HisD Hseq. 
  inversion Hseq...
 cut(False);intros...
 refine (onlyAtomsLinear _ H0 H1)...
 apply isOLLEncode... 
 apply onlyAtomsClassical in H1...
 apply isOLLEncode... 
  inversion H1...
  inversion H3...
  + apply FocusingClause in H2...
      rewrite Permutation_cons_append in H7.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H7.  
      apply checkEncodeCasesU in H7...
      apply OLInPermutation' in H2... inversion H2...
      destruct C... 
      simpl in H8. inversion H8...
      apply NoUinL in H7...
  + apply FocusingClause in H2...
      rewrite Permutation_cons_append in H7.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H7.  
      apply checkEncodeCasesD in H7...
      apply OLInPermutationL' in H2...
      rewrite H2... rewrite <- app_comm_cons...
      destruct C...
      simpl in H8. inversion H8...
      apply OLInPermutationL in H7...
      rewrite H7. 
      rewrite <- Permutation_middle...
      destruct C... 
      simpl in H8. inversion H8...
  + destruct C.
  + destruct C.
  +  apply FocusingClause in H2...
      rewrite Permutation_cons_append in H7.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H7.  
      apply checkEncodeCasesU in H7...
      apply OLInPermutation' in H2... inversion H2...
      destruct C...
      -
      simpl in H8.      
      invTri H8. invTri H10.
      invTri H9.  
     apply LMOrR1. 
       eapply H with (m:=n0)...
      inversion H4... inversion H6...
      invTri H10.
      invTri H9.  
     apply LMOrR2. 
       eapply H with (m:=n0)...
      inversion H4... inversion H6...
      -
      simpl in H8.   
      invTri H8. invTri H11.
      invTri H10. invTri H13.
      apply LMAndR.
      eapply H with (m:=n0)...
      inversion H4... inversion H2...
      apply BangConN in H12...
      simpl in H5...
      LLExact H12. 
      eapply H with (m:=n0)...
      inversion H4... inversion H2...
      apply BangConN in H11...
      simpl in H5...
      LLExact H11. 
      -
      simpl in H8.  
      apply LMImpR. rewrite !app_comm_cons.
       
      invTri H8. invTri H11. 
      invTri H9. invTri H12.   
      eapply H with (m:=n1)...
      inversion H4... inversion H2...
      inversion H4... inversion H2...
       apply BangConN in H11...
      simpl in H5...
      LLExact H11. 
      simpl...
      - apply NoUinL in H7... 

  + apply FocusingClause in H2...
     rewrite Permutation_cons_append in H7.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H7.  
      apply checkEncodeCasesD in H7...
      apply OLInPermutationL' in H2...
      rewrite H2...
      destruct C...
      -
      simpl in H8. rewrite <- app_comm_cons. 
      apply LMOrL. 
      invTri H8. invTri H12. 
      invTri H11. rewrite app_comm_cons. 
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
      rewrite H2 in HisL...
      LLExact H13. 
      rewrite <- H5...
      invTri H8. invTri H12. 
      invTri H14. rewrite app_comm_cons. 
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
      rewrite H2 in HisL...
      LLExact H13. 
      rewrite <- H5...
      -
      simpl in H8. 
      invTri H8. rewrite <- app_comm_cons.  
      apply LMAndL1. rewrite app_comm_cons. 
      invTri H11. invTri H12. 
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
      rewrite H2 in HisL...
      LLExact H13. 
      rewrite <- H5... rewrite <- app_comm_cons.
      apply LMAndL2. rewrite app_comm_cons. 
      invTri H11. invTri H12. 
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
      rewrite H2 in HisL...
      LLExact H13. 
      rewrite <- H5...
      -
      simpl in H8.
      invTri H8. 
      invTri H13. invTri H14.
      invTri H11. invTri H13.
      rewrite H9 in H5.
      apply GenLMCL_rev.
      LMPerm (F0 ⇒' G :: R++(x1 ++ R)).

      apply LMImpL. 
      rewrite <- (app_nil_l R).
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
     rewrite app_comm_cons.
      eapply H with (m:=n0)...
      inversion H4... inversion H6...
      rewrite H2 in HisL... 
      LLExact H14. rewrite <- H5...
      -
      apply OLInPermutationL in H7...
      rewrite H7. 
      rewrite <- Permutation_middle...
      destruct C...
      { simpl in H8. 
        apply LMCL.
        apply LMOrL. 
        rewrite (Permutation_middle L)...
        rewrite <-  H7.
        invTri H8. invTri H11. 
        invTri H10. rewrite app_comm_cons. 
        eapply H with (m:=n0)...
        inversion H4... inversion H2...
        LLExact H12. simpl...
        rewrite (Permutation_middle L)...
        rewrite <-  H7.
        invTri H8. invTri H11. 
        invTri H13. rewrite app_comm_cons. 
        eapply H with (m:=n0)...
        inversion H4... inversion H2...  LLExact H12. simpl...
        }
      { simpl in H8. 
        invTri H8. 
        apply LMCL.
        apply LMAndL1. 
        rewrite (Permutation_middle L)...
        rewrite <-  H7.
        invTri H10. invTri H11. 
        rewrite app_comm_cons. 
        eapply H with (m:=n0)...
        inversion H4... inversion H2...
        LLExact H12. simpl...
        apply LMCL.
        apply LMAndL2. 
        rewrite (Permutation_middle L)...
        rewrite <-  H7.
        invTri H10. invTri H11. 
        rewrite app_comm_cons. 
        eapply H with (m:=n0)...
        inversion H4... inversion H2... LLExact H12. simpl... }
       { simpl in H8.
        invTri H8. invTri H12. 
        invTri H13. invTri H10.
        invTri H12.
         apply LMCL.
        rewrite (Permutation_middle L)...
        rewrite <-  H7. rewrite app_comm_cons.
       apply GenLMCL_rev.
      LMPerm (F0 ⇒' G ::R++ (L ++ R)).
        apply LMImpL. 
       2: rewrite !app_comm_cons.
       rewrite <- (app_nil_l R). 
        1-2: eapply H with (m:=n0)...
        inversion H4... inversion H2...
inversion H4... inversion H2...
       LLExact H13. rewrite <- H6... }
  + destruct C. 
  + destruct C. 
  + apply FocusingInitRuleU in H2...
     - simpl in H4.
      rewrite Permutation_cons_append in H4.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H4.  
       apply checkEncodeCasesU in H4...
       assert(In (⌊ OO ⌋) (⌜ x ⌝)).
        rewrite H7.
       firstorder.
      apply NoDinR in H4...
      rewrite H7 in H2...
      assert(L = [OO]).
      eapply MapLEncodeEqual... 
      assert([D] = [OO]).
      eapply MapREncodeEqual... 
     apply GenLMWL_rev. inversion H5...
     - inversion H4... 
       apply OLInPermutationL in H6...
       apply GenLMWL.
      rewrite H6...
      LMPerm ([OO]++x). apply GenLMWL_rev...
  + apply FocusingClause in H2...
     -rewrite Permutation_cons_append in H6.
      change ( ⌞ L ⌟ ++ [⌈ D ⌉]) with (⌞ L ⌟ ++ REncode [D ]) in H6.  
        apply checkEncodeCasesD in H6...
        apply OLInPermutationL' in H2...
        rewrite H2...
        invTri H7. invTri H11.
        LMPerm(x1 ++ (OO::R)) .
        eapply H with (m:=n1)...
        LLExact H9. rewrite <- H4...
     - apply OLInPermutationL in H6...
        rewrite H6...
        invTri H7. invTri H10.
        LMPerm(OO::L++x0).
        apply LMCL. 
        rewrite (Permutation_middle L)...
        rewrite <-  H6. rewrite (Permutation_middle L)...
         eapply H with (m:=n1)...
  + destruct f.
 Qed.

(** LM+CUT -> LL(LM) *)
Theorem SoundenessCFLL: 
forall x L C, 
                            isOLFormulaL L ->
                                isOLFormula C ->
                  LMSeq (P:=wc) (n:=x) L C ->
                                FLLS (OLTheoryCutI PnN x) (LEncode L)  [⌈C⌉] (UP []).
Proof with sauto; try OLSolve;try solveLL. 
    intros *. 
    intros isFL1 isFL2 HM.
   induction HM;simpl...
   + LLtheory (makeRRuleC TT).
      LLtensor [⌈ t_ccon TT ⌉] (@nil oo)... 
      simpl. solveLL.
   + LLtheory (makeLRuleC FF).
      LLtensor (@nil oo) [⌈ C ⌉]... 
      simpl. solveLL.
  + LLtheory (RINIT F).
      inversion H.
     LLtensor [⌈ F ⌉] (@nil oo) ;solveLL.
  + LLtheory (makeRRuleB AND F G). 
     LLtensor [⌈ F ∧'  G ⌉] (@nil oo) ;solveLL.
     simpl. solveLL.
     1-2: LLfocus1...
     apply IHHM1...
    inversion isFL2...
    inversion H...
    apply IHHM2...
    inversion isFL2...
    inversion H...
  + simpl in IHHM...
     LLtheory (makeLRuleB AND F G). 
    apply oothc_theoryi. apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo) [⌈ C ⌉] ;solveLL.
   simpl;solveLL.
    LLleft. solveLL. apply weakening...
   PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ F ⌋::LEncode L).
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     LLtheory (makeLRuleB AND F G). 
   apply oothc_theoryi.  apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
   simpl;solveLL.
    LLright. solveLL.
apply weakening...
   PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ G ⌋::LEncode L).

   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     LLtheory (makeRRuleB OR F G). 
     LLtensor [⌈ F ∨' G ⌉ ] (@nil oo) ;solveLL.
   simpl;solveLL.
    LLleft. solveLL. 
   apply IHHM...
   inversion isFL2...
  inversion H...
  + simpl in IHHM...
     LLtheory (makeRRuleB OR F G). 
     LLtensor [⌈ F ∨' G ⌉ ] (@nil oo) ;solveLL.
   simpl;solveLL.
    LLright. solveLL.
   apply IHHM...
   inversion isFL2...
  inversion H...
  + simpl in IHHM1,IHHM2...
     LLtheory (makeLRuleB OR F G). 
  apply oothc_theoryi.   apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo) [⌈ C ⌉] ;solveLL.
   simpl. solveLL.
  1-2: apply weakening...
  1-2: PosNeg... inversion isFL1... inversion H1... inversion H...
   LLPerm(⌊ F ⌋::LEncode L).

   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   inversion isFL1...
  inversion H1...
  inversion H...

   LLPerm(⌊ G ⌋::LEncode L).
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
 + simpl in IHHM...
     LLtheory (makeRRuleB IMP F G). 
     LLtensor [⌈ F ⇒' G ⌉] (@nil oo) ;solveLL.
   simpl. solveLL.
   LLPerm([⌊ F ⌋ ; ! ⌈ G ⌉]).
   PosNeg... 
   inversion isFL2...
  inversion H...
   LLPerm(⌊ F ⌋::LEncode L).
   LLfocus1...
   apply IHHM...
   inversion isFL2...
  inversion H...
   inversion isFL2...
  inversion H...
  + simpl in IHHM1,IHHM2...
     LLtheory (makeLRuleB IMP F G). 
apply oothc_theoryi.     apply ooth_rules .
    constructor.
    inversion isFL1...
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
   simpl. 
     LLtensor (@nil oo)  [⌈ C ⌉] ;solveLL.
    1-2:apply weakening...
     rewrite LEncodeApp. 
     apply weakeningGen_rev.
   apply IHHM1...
   inversion isFL1...
  inversion isFL1...
  inversion H1...
  inversion H...
     rewrite LEncodeApp. 
     apply weakeningGen.
    PosNeg...
   inversion isFL1...
  inversion H1...
  inversion H...
  LLPerm(⌊ G ⌋::LEncode L2).

   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H. apply IHHM...
  +  LLtheory (POS F )... inversion H. 
  apply oothc_theoryi.      apply ooth_strpos.
    constructor. inversion isFL1...
      LLtensor (@nil oo) [⌈ C ⌉];solveLL.
      apply weakeningGen_rev.
     apply weakening.
     apply IHHM...
  +  LLtheory (POS F ). inversion H. 
   apply oothc_theoryi.     apply ooth_strpos.
    constructor. inversion isFL1...
      LLtensor (@nil oo) [⌈ C ⌉];solveLL.
      simpl in IHHM...
      LLPerm (⌊ F ⌋ :: ⌊ F ⌋ :: ⌞ L ⌟).
      apply IHHM...
      inversion isFL1...
 + simpl in IHHM1,IHHM2...
     LLtheory (RCUTI F).
     inversion H1. eapply oothc_cutni.
    eapply ctni with (m:=x)... 
     LLtensor (@nil oo) [⌈ C ⌉] ...
    rewrite LEncodeApp...
   apply weakeningGen...
    apply IHHM2...
    rewrite LEncodeApp...
   apply weakeningGen_rev...
    PosNeg...
 rewrite <- Permutation_cons_append.
    
    apply IHHM1...
   inversion isFL2...
  Qed.

Theorem SoundenessCFLL': forall x L R C, 
              isOLFormulaL L -> isOLFormulaL R ->  isOLFormula C ->
                  LMSeq (P:=wc) (n:=x) (L++R) C ->
                     FLLS (OLTheoryCutI PnN x)  (LEncode R)  (⌈C⌉ :: (LEncode L)) (UP []).
Proof with sauto.
   intros .
   apply SoundenessCFLL in H2...
   LLPerm ( ([⌈ C ⌉] ++ ⌞ L ⌟)) . apply PosSetP...
   rewrite <- LEncodeApp...
  apply Forall_app...
Qed. 
 

Theorem CutElimLM: forall x L C, 
                            isOLFormulaL L ->
                                isOLFormula C ->
                  LMSeq (P:=wc) (n:=x) L C -> LMSeq (P:=wnc) (n:=x) L C.
Proof with sauto.
 intros.
 assert(exists R1 R2, Permutation L (R1++R2)).
 eexists nil, L... 
  CleanContext. 
 rewrite H2 in H1.  
assert(isOLFormulaL x0 /\ isOLFormulaL x1)...
rewrite H2 in  H; OLSolve.
 rewrite H2 in  H; OLSolve.
 
apply  SoundenessCFLL' in H1...
 specialize(OLCutElimination  wellFormedLM CutCoherenceLM wellFormedI);intros.
 apply H3 in H1... all: try clear H3.
  apply FLLStoFLLN in H1...
eapply CompletenessFLL  in H1... 
rewrite H2...  exact H1.
apply Forall_cons... apply isOLLEncodeB...
Qed.
 
 Theorem CutAdmLM: forall x F L1 L2 C, 
      isOLFormulaL L1 ->  isOLFormulaL L2 -> isOLFormula C -> lengthUexp F x -> isOLFormula F -> 
LMSeq (P:=wnc) (n:=x) (F::L1) C -> LMSeq (P:=wnc) (n:=x) L2 F -> LMSeq (P:=wnc) (n:=x) (L1++L2) C.
Proof with sauto.
  
 intros. 
 eapply CutElimLM... 
apply Forall_app...
eapply LMCut with (F:=F)... 
1-2: apply SoundnessLM...
Unshelve.
eauto.
Qed.


Lemma OLFormulaLeng F: isOLFormula F -> exists x, lengthUexp F x.
Proof with sauto.
 intro H. induction H;intros...
 - eexists...
 - inversion H...
    eexists...
 - eexists (S x)...
 - eexists (S (x0+x))...
 - assert(proper  (Var 0%nat)). 
    apply proper_VAR. 
    apply H1 in H2... 
    eexists (S x)...
Qed.
   
