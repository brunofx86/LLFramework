
(** * System LJ for classical logic encoded as an LL theory

This file encodes the inference rules of the system LJ. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)


Require Import LL.SL.FLL.Specifications.Intuitionistic.OLCut.
Require Import LL.SL.FLL.Reasoning.
 
(** ** Syntax *)
(* conjunction, disjunction and implication *)
Inductive LJCon := OR | AND  | IMP .

#[local]Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    ccon := Empty_set ;
    ucon := Empty_set;
    bcon := LJCon ;
    qcon := Empty_set
  |}.


(** ** Inference rules *)

(** *** Constants *)
Definition LJrulesC (c:ccon) :=
  match c return ruleC with
  end.

(** *** Unary connectives *)
Definition LJrulesU (c:ucon) :=
  match c return ruleU with
  end.

(** *** Binary connectives *)
Definition LJrulesB (c:bcon) :=
  match c with
  | OR => {| rb_rgtBody := fun F G => AOr  (Bang (atom (up F))) (Bang (atom (up G) ));
                 rb_lftBody  := fun F G => AAnd (atom (down F) ) (atom (down G)) |}
  | AND => {| rb_rgtBody := fun F G => AAnd  (Bang (atom (up F))) (Bang (atom (up G) ));
                 rb_lftBody  := fun F G => AOr (atom (down F) ) (atom (down G)) |}
  | IMP => {| rb_rgtBody := fun F G => MOr (atom (down F)) (Bang (atom (up G)) );
                 rb_lftBody  := fun F G => MAnd (Bang (atom (up F)) ) (atom (down G)) |}
  end.

(** *** Quantifiers *)
Definition LJrulesQ (c:qcon) :=
  match c return ruleQ with
  end.


#[local] Instance SimpleOORUles : OORules :=
  {|
    rulesC := LJrulesC;
    rulesU := LJrulesU;
    rulesB := LJrulesB;
    rulesQ := LJrulesQ
  |}.
  
Ltac solveTF :=
   match goal with
| [H: IsPositiveAtom (makeLRuleB _ _ _) |- _ ] => inversion H 
| [H: IsPositiveAtom (makeRRuleB _ _ _) |- _ ] => inversion H 
end.

Lemma wellFormedConstant : wellFormedC'.
Proof with sauto.
  unfold wellFormedC';intros.
  destruct lab.
Qed.

Lemma wellFormedUnary : wellFormedU'.
Proof with sauto. 
  unfold wellFormedU';intros.
  destruct lab.
Qed.

Lemma wellFormedQuantifier : wellFormedQ'.
Proof with sauto.
  unfold wellFormedQ'. intros.
  destruct lab.
Qed.

Require Import LL.SL.FLL.InvPositivePhase.


Lemma wellFormedBinary : wellFormedB'.
Proof with sauto.
  unfold wellFormedB';intros.
  destruct lab;destruct s.
 + exists Requirement1.BTwoPA.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingWith in H4...
      exists x0, [⌊ Fo1 ⌋],  [⌊ Go1 ⌋], x1, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      left. split... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H2.
      LLExact H5.
      lia. intros.
      TFocus (makeLRuleB OR Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon OR Fo1 Go1 ⌋ ] Delta12. 
      simpl. solveLL. LLExact H1. LLExact H4.
    - apply FocusingWith in H4...
      exists Delta, [⌊ Fo1 ⌋],  [⌊ Go1 ⌋], x0, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      right. split... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H2.
      LLExact H5.
      lia. intros. 
      simpl; solveLL. 
      LLExact H. LLExact H1.
  + exists Requirement1.BOneP.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingPlusPos in H4...
      exists [!⌈ Fo1 ⌉], (S (S (S x1))), 1%nat.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      left. exists []...
      FLLleft. solveLL. 
      apply seqNtoSeq in H5...
      LFocus. 
      lia. intros.
      LLPerm ([⌈ t_bcon OR Fo1 Go1 ⌉] ++ Delta1++[]).
      eapply InvTensorT'. exact H. solveLL.
      simpl... solveLL.
      eapply InvPlus... solveLL. LLExact H1.       
exists [!⌈ Go1 ⌉], (S (S (S x1))), 1%nat.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      left. exists []...
      FLLright. solveLL. 
      apply seqNtoSeq in H5...
      LFocus. 
      lia. intros.
  LLPerm ([⌈ t_bcon OR Fo1 Go1 ⌉] ++ Delta1++[]).
      eapply InvTensorT'. exact H. solveLL.
      simpl... solveLL.
      eapply InvPlusComm... solveLL. LLExact H1.       

    - apply FocusingPlusPos in H4...
      exists [!⌈ Fo1 ⌉], (S (S (S x0))), 1%nat.
      split... do 2 constructor... 
      inversion H0...  inversion H...
      right... 
      FLLleft. solveLL. 
      apply seqNtoSeq in H5...
      LFocus.
      lia. intros.
      simpl;solveLL...  
      eapply InvPlus... solveLL. LLExact H.        
      
      exists [!⌈ Go1 ⌉], (S (S (S x0))), 1%nat.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      right... 
      FLLright. solveLL. 
      apply seqNtoSeq in H5...
       LFocus.
      lia. intros.
      simpl... solveLL.
      eapply InvPlusComm... solveLL. LLExact H.       

  + exists Requirement1.BOneP.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingPlus in H4...
      exists [⌊ Fo1 ⌋], x1, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      left. exists x0...
      FLLleft. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2.
      lia. intros.
      TFocus (makeLRuleB AND Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon AND Fo1 Go1 ⌋] Delta1. 
      FLLleft. solveLL. LLExact H1.
      exists [⌊ Go1 ⌋], x1, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      left. exists x0...
      FLLright. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2.
      lia. intros.
      TFocus (makeLRuleB AND Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon AND Fo1 Go1 ⌋] Delta1. 
      FLLright. solveLL. LLExact H1.
    - apply FocusingPlus in H4...
      exists [⌊ Fo1 ⌋], x0, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H...
      right... 
      FLLleft. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2.
      lia. intros. simpl. solveLL.
     apply InvPlus... solveLL.
     LLExact H.
      exists [⌊ Go1 ⌋], x0, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      right...
 simpl. 
      FLLright. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2.
      lia. intros.
 simpl. solveLL.
     apply InvPlusComm... solveLL.
     LLExact H.
 + exists Requirement1.BTwoPA.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingWithPos in H4...
      exists x0, [!⌈ Fo1 ⌉],  [!⌈ Go1 ⌉], x1, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      left. split... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
(*       apply BangConN in H2... *)
      LLExact H2.
(*       apply BangConN in H5... *)
      LLExact H5. 
      lia. intros.
      TFocus (makeRRuleB AND Fo1 Go1).
      solveTF. 
      FLLsplit [⌈ t_bcon AND Fo1 Go1 ⌉ ] Delta12.
     simpl. solveLL. LLExact H1. LLExact H4.  
    - apply FocusingWithPos in H4...
      exists Delta, [!⌈ Fo1 ⌉],  [!⌈ Go1 ⌉], x0, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      right. split... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
(*      apply BangConN in H2... *)
      LLExact H2.
(*       apply BangConN in H5... *)
      LLExact H5.
      lia. intros.
     simpl; solveLL. LLExact H. LLExact H1.
 + exists Requirement1.BTwoPM.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingTensorPos in H4...
      exists  x0, [⌈ Fo1 ⌉],  [⌊ Go1 ⌋], x1, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      left. split... simpl. 
      FLLsplit (@nil oo) x0; solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H5.
      lia. intros.
      TFocus (makeLRuleB IMP Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon IMP Fo1 Go1 ⌋ ] (Delta0). 
      simpl. FLLsplit (@nil oo) (Delta0); solveLL.  LLExact H4.
    - apply FocusingTensorPos in H4...
      exists Delta, [⌈ Fo1 ⌉],  [⌊ Go1 ⌋], x0, 4.
      split... do 2 constructor... 
      inversion H0...  inversion H... 
      do 2 constructor... 
      inversion H0...  inversion H... 
      right. split... simpl. solveLL.
      FLLsplit (@nil oo) Delta; solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H5.
      lia. intros.
      simpl; solveLL. 
     LLPerm ((! ⌈ Fo1 ⌉) ⊗ ⌊ Go1 ⌋ :: []++Delta0).
     apply InvTensor';solveLL... LFocus.   LLExact H1.
  + exists Requirement1.BOneP.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingParPos in H4...
      exists [!⌈ Go1 ⌉ ; ⌊ Fo1 ⌋], x1, 5.
      split... constructor... constructor... 
      inversion H0...  inversion H...
      constructor... constructor... 
      inversion H0...  inversion H...

      left. exists x0...
      simpl.  solveLL. 
      apply seqNtoSeq in H1...
      LLExact H1.
      lia. intros.
      TFocus (makeRRuleB IMP Fo1 Go1).
      solveTF. 
      FLLsplit [⌈ t_bcon IMP Fo1 Go1 ⌉] Delta1. 
      simpl. solveLL.  LLExact H2. 
    - apply FocusingParPos in H4...
      exists [!⌈ Go1 ⌉ ; ⌊ Fo1 ⌋], x0, 5.
      split... constructor... constructor... 
      inversion H0...  inversion H...
      constructor... constructor... 
      inversion H0...  inversion H...

      right... 
      simpl.  solveLL. 
      apply seqNtoSeq in H1...
      LLExact H1.
      lia. intros.
      simpl; solveLL. LLExact H.
Qed.

Lemma wellFormedT : wellFormedTheory'.
Proof.
  split.
  apply wellFormedConstant.
  split.  
 apply wellFormedUnary. 
  split. 
apply wellFormedBinary. 
 apply wellFormedQuantifier.
Qed.

Lemma wellFormedConstantI : wellFormedCI.
Proof with sauto.
  unfold wellFormedCI;intros.
  destruct lab.
Qed.

Lemma wellFormedUnaryI : wellFormedUI.
Proof with sauto. 
  unfold wellFormedUI;intros.
  destruct lab.
Qed.

Lemma wellFormedQuantifierI : wellFormedQI.
Proof with sauto.
  unfold wellFormedQI. intros.
  destruct lab.
Qed.


Lemma checkEncodeCasesD'
     : forall (L : list uexp) (x : list oo) (F G : uexp),
  Permutation (atom (up G) :: ⌞ L ⌟ ) (⌊ F ⌋ :: x) ->
       exists x1 : list uexp,
         Permutation (⌞ L ⌟) (⌊ F ⌋ :: ⌞ x1 ⌟) /\
         Permutation (atom (up G) :: ⌞ x1 ⌟ ) x.
Proof with sauto.
   intros.
   assert(Permutation (⌈ G ⌉ :: ⌞ L ⌟) ( LEncode L ++ REncode [G]))...
   rewrite H0 in H.
   apply checkEncodeCasesD in H...
   exists x0... rewrite <- H2...
Qed.

 Lemma wellFormedBinaryI : wellFormedBI.
Proof with sauto.
  unfold wellFormedBI;intros.
  destruct lab.
 + exists Requirement1.BTwoPA.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingWith in H4...
     apply checkEncodeCasesD' in H3... 
      exists x, [ Fo1 ],  [ Go1 ], x1, 4.
      split...  constructor... 
      inversion H0...  inversion H3... 
      constructor... 
      inversion H0...  inversion H3... 
      left. split... rewrite H1... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5... 
      LLExact H2.  rewrite <- H1... rewrite LEncodeApp...
      LLExact H5.  rewrite <- H1... rewrite LEncodeApp...
      lia. intros.
      TFocus (makeLRuleB OR Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon OR Fo1 Go1 ⌋ ]  Delta12.
      simpl. solveLL. LLExact H4. LLExact H6.
    - apply FocusingWith in H4...
      exists Delta, [ Fo1 ],  [ Go1], x0, 4.
      split... constructor... 
      inversion H0...  inversion H... 
      constructor... 
      inversion H0...  inversion H... 
      right. split... simpl. solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H2. simpl... 
      LLExact H5. simpl...
      lia. intros.
    (*   TFocus (makeLRuleBin OR Fo1 Go1).
      solveTF. 
   FLLsplit (@nil oo) (⌈ F ⌉ :: ⌞ Delta12 ⌟).       *) 
      simpl. solveLL. 
      LLExact H. LLExact H1.
  + exists Requirement1.BOneP.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingPlus in H4...
       apply checkEncodeCasesD' in H3...  
       exists   [Fo1 ], x1, 4.
      split...
     constructor... 
      inversion H0...  inversion H3...  
     left. exists x. split... 
      rewrite H1...
      FLLleft. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2. rewrite <- H1 ... rewrite LEncodeApp...
      lia. intros.
      TFocus (makeLRuleB AND Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon AND Fo1 Go1 ⌋ ] Delta1.
      FLLleft. solveLL. LLExact H4. 

       apply checkEncodeCasesD' in H3...  
       exists  [Go1 ], x1, 4.
      split...
     constructor... 
      inversion H0...  inversion H3...  
     left. exists x. split... 
      rewrite H1...
      FLLright. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2.   rewrite <- H1 ... rewrite LEncodeApp...
      lia. intros.
      TFocus (makeLRuleB AND Fo1 Go1).
      solveTF. 
      FLLsplit [⌊ t_bcon AND Fo1 Go1 ⌋ ] Delta1.
      FLLright. solveLL. LLExact H4. 
     - apply FocusingPlus in H4...
       exists  [Fo1 ], x0, 4.
      split...
     constructor... 
      inversion H0...  inversion H...  
     right. split... 
      FLLleft. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2. 
      lia. intros.
  FLLleft. solveLL. LLExact H. 
exists  [Go1 ], x0, 4.
      split...
     constructor... 
      inversion H0...  inversion H...  
     right. split... 
      FLLright. solveLL. 
      apply seqNtoSeq in H2...
      LLExact H2. 
      lia. intros.
  FLLright. solveLL. LLExact H.
 + exists Requirement1.BTwoPM.
     do 3 intro. intros. 
     apply FocusingClause in H...
    - apply FocusingTensorPos in H4...
       apply checkEncodeCasesD' in H3...  
       exists x. exists [Go1], [⌈ Fo1 ⌉], x1, 4.
      split... 1-2: constructor...  inversion H0... inversion H3... 
 constructor...  inversion H0... inversion H3...
      left. split... simpl. 
      FLLsplit (@nil oo)  (⌞ x ⌟ ++ [⌈ F ⌉]) ; solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H5.   rewrite <- H1...
LLExact H5.   rewrite <- H1... rewrite LEncodeApp...
      lia. intros. 
      LLPerm ([⌊ t_bcon IMP Fo1 Go1 ⌋] ++ (Delta0)).
     eapply InvTensorT'. exact H3. solveLL.  simpl.  solveLL. 
      LLPerm ((! ⌈ Fo1 ⌉) ⊗ ⌊ Go1 ⌋ :: [ ] ++  Delta0).
       eapply InvTensor';solveLL. LFocus. 
 LLExact H4. 
    - apply FocusingTensorPos in H4...
     exists Delta, [Go1 ]. exists [⌈ Fo1 ⌉], x0, 4.
    split...  
    1-2: constructor...
    inversion H0...
    inversion H...
constructor...
    inversion H0...
    inversion H...
right.
      split... 
      FLLsplit (@nil oo)  (⌞Delta⌟ ++ [⌈ F ⌉]) ; solveLL. 
      apply seqNtoSeq in H2...
      apply seqNtoSeq in H5...
      LLExact H5. LLExact H5. rewrite LEncodeApp... 
      lia. intros. simpl;solveLL.
        FLLsplit (@nil oo)  Delta0; solveLL. 
 LLExact H. 
Qed.

Lemma wellFormedI : wellFormedTheoryI.
Proof.
  split.
  apply wellFormedConstantI.
  split.  
 apply wellFormedUnaryI. 
  split. 
apply wellFormedBinaryI. 
 apply wellFormedQuantifierI.
Qed.

(** ** Cut-coherency properties *)

(** *** Binary Connectives *)
Lemma CutCoherenceOR: CutCoherenceBin cutR2 (rulesB OR).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  apply InvPlus...
  apply InvPlusComm...
Qed.


Lemma CutCoherenceAND: CutCoherenceBin cutR2 (rulesB AND).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm  [(? ⌈ F ⌉^) ⊕ (? ⌈ G ⌉^); ⌊ F ⌋^].
  apply InvPlus...
  LLPerm  [(? ⌈ F ⌉^) ⊕ (? ⌈ G ⌉^); ⌊ G ⌋^].
  apply InvPlusComm...
Qed.

Lemma CutCoherenceIMP: CutCoherenceBin cutR2 (rulesB IMP).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm  ((⌊ F ⌋^ ⊗ (? ⌈ G ⌉^)):: ([]++[⌊G ⌋^])).
  apply InvTensor'...
  simpl...
  apply weakening...
Qed.
 
Lemma CutCoherence_p : CutCoherence cutR2.
Proof.
  split;intros. destruct lab.
  split;intros; try destruct lab.
  split;intros; try destruct lab. 
  apply CutCoherenceOR.
   apply CutCoherenceAND.
  apply CutCoherenceIMP.
Qed.
 
(* Require Import LL.OL.Intuitionistic.OLCutBang.
 *)
(*  Check OLCutElimination wellFormedT CutCoherence_p wellFormedI .  *)

Lemma CutCoherenceOR': CutCoherenceBin cutR1 (rulesB OR).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  apply InvPlus...
  apply InvPlusComm...
Qed.


Lemma CutCoherenceAND': CutCoherenceBin cutR1 (rulesB AND).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm  [(? ⌈ F ⌉^) ⊕ (? ⌈ G ⌉^); ⌊ F ⌋^].
  apply InvPlus...
  LLPerm  [(? ⌈ F ⌉^) ⊕ (? ⌈ G ⌉^); ⌊ G ⌋^].
  apply InvPlusComm...
Qed.

Lemma CutCoherenceIMP': CutCoherenceBin cutR1 (rulesB IMP).
Proof with sauto; try solveLL.
  unfold CutCoherenceBin;intros.
  simpl...
  LLPerm  ((⌊ F ⌋^ ⊗ (? ⌈ G ⌉^)):: ([]++[⌊G ⌋^])).
  apply InvTensor'...
  simpl...
  apply weakening...
Qed.
 
Lemma CutCoherence_p' : CutCoherence cutR1.
Proof.
  split;intros. destruct lab.
  split;intros; try destruct lab.
  split;intros; try destruct lab. 
  apply CutCoherenceOR'.
   apply CutCoherenceAND'.
  apply CutCoherenceIMP'.
Qed.

(** An inductive definition for LJ. This will be used to prove that
the LL encoding is sound and complete *)

Record withcut := { cut : bool }.

Definition nC := {| cut := false |}.
Definition wC :=  {| cut := true |}.

Inductive LJSeq P {n} : list uexp -> uexp -> Prop :=
(* axioms *)
| LJInit : forall F,  LJSeq P [F] F

(* conjunction *)
| LJAndL1 : forall L C F G, LJSeq P (F :: L) C -> LJSeq P ( (t_bcon AND F G) :: L) C
| LJAndL2 : forall L C F G, LJSeq P (G :: L) C -> LJSeq P ( (t_bcon AND F G) :: L) C
| LJAndR : forall L F G , LJSeq P L F -> LJSeq P L G -> LJSeq P L (t_bcon AND F G)

(* implication *)
| LJImpL : forall L1 L2 C F G , LJSeq P L1 F -> LJSeq P (G::L2) C -> LJSeq P (t_bcon IMP F G ::L1++L2) C
| LJImpR : forall L F G, LJSeq P (F::L) G ->  LJSeq P L (t_bcon IMP F G )

(* exchange, contraction and weakening*)
| LJEx : forall C L L', Permutation L L' -> LJSeq P L C -> LJSeq P L' C
| LJCt : forall C L F, LJSeq P (F :: F :: L)  C -> LJSeq P (F :: L)  C
| LJWk : forall C L F, LJSeq P  L C -> LJSeq P (F :: L)  C

(* cut *)
| LJCut {f : cut P = true} : forall C L1 L2 F,  lengthUexp F n ->  isOLFormula F ->  LJSeq P L1 F -> LJSeq P (F::L2) C -> LJSeq P (L1++L2) C
.

#[local] Hint Constructors LJSeq : core .

Global Instance LJ_morph n P: 
  Proper ((@Permutation uexp) ==> eq ==> iff) (LJSeq P (n:=n)).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LJEx;eauto.
  apply Permutation_sym in H.
  eapply LJEx;eauto.
Qed.

Theorem LJConGen: forall n P L L1 C, 
                  LJSeq  P (n:=n) (L++L1++L1) C -> LJSeq P (n:=n) (L++L1) C. 
Proof with sauto. 
    intros *.
    revert L C P. 
    induction L1; intros... 
   rewrite Permutation_midle.
   apply LJCt.
  assert(Permutation (L ++ (a :: L1) ++ a :: L1) ((a::a::L) ++ L1++ L1))...
  rewrite H0 in H. 
   apply IHL1 in H...
Qed.

Theorem LJWeaGen: forall n P L L1 C, 
                  LJSeq P (n:=n) L C -> LJSeq P (n:=n) (L++L1) C. 
Proof with sauto. 
    intros *.
    revert L C P. 
    induction L1; intros... 
   rewrite Permutation_midle.
   apply LJWk.

   apply IHL1 in H...
Qed.

Theorem SoundnessLJ: forall n L C, 
                  LJSeq nC (n:=n) L C -> LJSeq wC (n:=n) L C. 
Proof with sauto. 
    intros *. 
    intros HM.
   induction HM;simpl...
   rewrite <- H...
Qed.
    
Theorem SoundenessFLL: forall n L C, 
                  isOLFormulaL L ->
                  isOLFormula C ->
                 LJSeq wC (n:=n) L C ->
                                flls (OLTheoryCut PnN n) (LEncode L)  (REncode [C]) (UP []).
Proof with sauto; try OLSolve. 
    intros *. 
    intros isFL isFC HM.
   induction HM;simpl...
10:{
simpl in IHHM1,IHHM2...
     TFocus (RCUTI F).
     inversion H1.
    eapply oothc_cutn. 
    eapply ctni with (m:=n)... 
    FLLsplit (@nil oo)  [⌈ C ⌉]. 
   solveLL.
    rewrite LEncodeApp.
   apply weakeningGen_rev.
   apply IHHM1...
   solveLL.
   apply PosF...
   intro. intros...
    rewrite LEncodeApp.
  rewrite app_assoc_reverse. 
  apply weakeningGen.
rewrite Permutation_app_comm.
 apply IHHM2... OLSolve. }



 
(⌞ L1 ⌟ ) .
 
     case IHHM1...
     inversion isFL2...
     intros... 
     case IHHM2...
     inversion isFL2...
     intros...
     eexists (x0+x1)...
     TFocus (RCUT F).
     inversion H1.
    eapply oothc_cutn.
    eapply ctn with (m:=x)...
    FLLsplit ( ⌞ L2 ⌟ ++ ⌜ R2 ⌝) (⌞ L1 ⌟ ++ ⌜ R1 ⌝) .
    rewrite LEncodeApp, REncodeApp...
    1-2: solveLL.
  
    LLPerm (⌞ L2 ⌟ ++ ⌈ F ⌉ :: ⌜ R2 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x1 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...

   LLPerm (⌊ F ⌋ :: ⌞ L1 ⌟ ++ ⌜ R1 ⌝).
   apply WeakTheory with (theory := OLTheoryCut nPnN x0 )...
   intros F' H'. 
   refine (TheoryEmb3 _ H')...
Qed



  + TFocus (RINIT F).
      inversion H.
     apply ooth_init.
     inversion isFL2...
     FLLsplit [⌈ F ⌉] [⌊ F ⌋] ;solveLL.
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleBin TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F *** G ⌉] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉:: ⌜ L2 ⌝).
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
   LLPerm (⌞ L1' ⌟ ++ ⌈ G ⌉ :: ⌜ L2' ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleBin TENSOR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F *** G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌊ F ⌋ :: ⌊ G ⌋ :: ⌞ L1 ⌟ ++ ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleBin PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F $$$ G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleBin PAR F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F $$$ G ⌋ ] (⌞ L1 ++ L1' ⌟ ++ ⌜ L2 ++ L2' ⌝) ;solveLL.
    FLLsplit (⌞ L1⌟ ++ ⌜ L2⌝)  (⌞L1' ⌟ ++ ⌜ L2' ⌝);solveLL .
   rewrite LEncodeApp;
   rewrite REncodeApp... 

   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeRRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [⌈ F ooo G ⌉  ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM1,IHHM2...
     TFocus (makeLRuleBin OPLUS F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F ooo G ⌋ ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   apply IHHM1...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
   apply IHHM2...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM1,IHHM2...
     TFocus (makeRRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL2...
     FLLsplit [ ⌈ F &* G ⌉  ] (⌞ L1⌟ ++ ⌜ L2 ⌝) ;solveLL.
    simpl;solveLL.
   LLPerm (⌞ L1 ⌟ ++ ⌈ F ⌉ :: ⌜ L2 ⌝) .
   apply IHHM1...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  LLPerm (⌞ L1 ⌟ ++ ⌈ G ⌉ :: ⌜ L2 ⌝).
   apply IHHM2...
   inversion isFL2...
  inversion H1...
  inversion H...
   inversion isFL2...
  + simpl in IHHM...
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLleft;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + simpl in IHHM...
     TFocus (makeLRuleBin WITH F G). 
     inversion H.
    apply ooth_rules .
    constructor.
    inversion isFL1...
     FLLsplit [⌊ F &* G ⌋ ] (⌞ L1⌟ ++ ⌜ L2⌝) ;solveLL.
   simpl;solveLL.
    FLLright;solveLL.
   apply IHHM...
   inversion isFL1...
  inversion H1...
  inversion H...
   inversion isFL1...
  + rewrite H in isFL2. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌈ x ⌉) ) in H.
      rewrite H. apply IHHM...
  + rewrite H in isFL1. 
     eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋) ) in H.
      rewrite H. apply IHHM...
Qed.

   (** Completeness theorem *)
Theorem Completeness: forall n L1 L2 C, 
  isOLFormula C ->    
  isOLFormulaL L1 ->
    isOLFormulaL L2 ->
    seqN (OLTheory PnN) n (LEncode L2) (LEncode L1++REncode [C]) (UP []) ->
    LJSeq nC (L1++L2) C.
Proof with sauto;try solveLL; try OLSolve.
  induction n using lt_wf_ind; intros *.  
  intros HisC HisL1 HisL2  Hseq. 
  inversion Hseq...

*
  cut(False);intros...
  refine (onlyAtomsLinear _ H0 H1)...
 apply isOLLEncode...
simpl...
*
  cut(False);intros...
 refine (onlyAtomsClassical _ H0 H1)...
 apply isOLLEncode...
*
  inversion H1...
  inversion H3...
  1-4:  destruct C0...
  3-4:  destruct C0...
 + apply FocusingClause in H2...
    apply checkEncodeCasesU in H7... 
    apply OLInPermutation' in H2...
    inversion H2...
    simpl in H5... 
   rewrite <- H5 in H8.
   clear H5.
   destruct C0...
    ++ apply FocusingWithPos in H8...
          apply BangConN in H6, H7. 
          eapply LJAndR.
          eapply H with (m:=x1)...
          inversion H4...
         inversion H2...
         LLExact H6.
          eapply H with (m:=x1)...
          inversion H4...
         inversion H2...
         LLExact H7.
         constructor.
constructor.
      ++ apply FocusingParPos in H8... 
          apply BangConN in H5. 
          eapply LJImpR.
         rewrite app_comm_cons.
         eapply H with (m:=x1)...
          inversion H4...
         inversion H2...
         inversion H4...
         inversion H2...
         LLExact H5.
        simpl...
         constructor.
     ++ apply NoUinL in H7... 
 + apply FocusingClause in H2...
   -
    apply checkEncodeCasesD in H7... 
    apply OLInPermutationL' in H2...
    rewrite H2...
rewrite <- app_comm_cons.
    destruct C0...
    ++ apply FocusingPlus in H8... 
          eapply LJAndL1.
         rewrite  app_comm_cons.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
          eapply LJAndL2.
         rewrite  app_comm_cons.
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H8.
         rewrite <- H5...
    ++ apply FocusingTensorPos in H8... 
         rewrite app_comm_cons.
         apply LJConGen.
         
         rewrite <- app_comm_cons.
         rewrite app_assoc.
        rewrite Permutation_app_comm.
          eapply LJImpL.
         rewrite <- (app_nil_l L2).
         eapply H with (m:=x2)...
          inversion H4...
         inversion H6...
rewrite  app_comm_cons.
  eapply H with (m:=x2)...
          inversion H4...
         inversion H6...

         rewrite H2 in HisL1.
         inversion HisL1...
         LLExact H10.
         rewrite <- H5...
   - apply OLInPermutationL in H7... 
     rewrite H7...
     rewrite <- Permutation_middle.
    destruct C0...
    ++ apply FocusingPlus in H8...
          apply LJCt. 
          eapply LJAndL1.
         rewrite  app_comm_cons.
          rewrite  app_comm_cons.
         eapply H  with (m:= (S (S (S (S x1)))))... 
          inversion H4...
         inversion H2...
        simpl...
        LLPerm ( ⌊ t_bcon AND F0 G ⌋ ::(⌊ F0 ⌋ ::  ⌞ L1 ⌟ ++ [⌈ C ⌉]) ).
       apply PosFN...
        intro. intros...
         LLExact H6.
         eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋)) in H7.
         rewrite H7...
         apply LJCt. 
          eapply LJAndL2.
         rewrite  app_comm_cons.
          rewrite  app_comm_cons.
         eapply H  with (m:= (S (S (S (S x1)))))... 
          inversion H4...
         inversion H2...
        simpl...
        LLPerm ( ⌊ t_bcon AND F0 G ⌋ ::(⌊ G ⌋ ::  ⌞ L1 ⌟ ++ [⌈ C ⌉]) ).
       apply PosFN...
        intro. intros...
         LLExact H6.
         eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋)) in H7.
         rewrite H7...
    ++ apply FocusingTensorPos in H8... 
          apply LJCt. 
          apply LJCt. 
         rewrite !app_comm_cons.
         apply LJConGen.
         rewrite <- app_comm_cons.

         assert (Permutation ( (t_bcon IMP F0 G :: t_bcon IMP F0 G :: L1) ++ x0 ++ x0)
                     ((t_bcon IMP F0 G :: x0) ++ (t_bcon IMP F0 G :: L1++x0)))...
        rewrite H2.
          eapply LJImpL.
assert(LJSeq nC ([]++(t_bcon IMP F0 G :: x0)) F0).
         eapply H with (m:=x1)...
          inversion H4...
         inversion H5...
         LLExact H6.
         eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋)) in H7.
         rewrite H7...
       simpl in H5...
      assert(Permutation (G :: t_bcon IMP F0 G :: L1 ++ x0) ((G::L1)++(t_bcon IMP F0 G :: x0)))...
      rewrite H5. 
        eapply H with (m:=x1)...
          inversion H4...
         inversion H8...
         LLExact H9.
         eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋)) in H7.
         rewrite H7...

 + apply FocusingInitRuleU in H2...
    apply checkEncodeCasesU in H4...
    rewrite H7 in H2.
    symmetry in H2.
   apply Permutation_length_2_inv in H2...
   rewrite H7 in H2.
   apply LJWeaGen.
      assert(L1 = [OO]).
   eapply MapLEncodeEqual... 
   assert([C] = [OO]).
   eapply MapREncodeEqual...
   inversion H5...
  apply OLInPermutationL in H6...
      assert(L1 =[]).
   eapply MapLEncodeEqual... 
   assert([C] = [OO]).
   eapply MapREncodeEqual...
   inversion H4...
   rewrite H6...
  rewrite perm_takeit_4.
 rewrite Permutation_app_comm.
   apply LJWeaGen...
+ apply FocusingStruct in H2...
   ++ apply checkEncodeCasesD in H6... 
         apply OLInPermutationL' in H2.
        rewrite H2.
assert(Permutation ((OO :: x1) ++ L2) (x1++(L2++[OO]) ))...
   rewrite H5.
eapply H with (m:=x)...
   LLExact H7.
  rewrite LEncodeApp...
   ++ apply OLInPermutationL in H6...
        rewrite H6.
       rewrite  Permutation_midle.
       apply LJCt.
 
      assert(Permutation (OO :: OO :: L1 ++ x0) (L1++(OO :: OO :: x0)))...
    rewrite H2.
eapply H with (m:=x)...
      rewrite H6 in HisL2...
   LLExact H7.
eapply Permutation_map with (f:=(fun x : uexp => ⌊ x ⌋)) in H6.
   rewrite H6...
         Qed.
  
 
 
     Variable LJSeq LJSeqC: list uexp -> list uexp -> Prop. 
Notation "'(' th ')' ⊢ B ';' L ⇑ F " := (seq th B L (UP F))  (at level 80).
 
Theorem AdequacyLJ:  forall L L' D D', 
   LJSeq (L ++ D) (L' ++ D') <->
    seq (LJTheory)
         (LEncode L ++ REncode L')
         (LEncode D ++ REncode D') (UP []).
Proof with sauto.   
    intros.
    Admitted.

Theorem AdequacyLJ':  forall L L' D D', 
   LJSeqC (L ++ D) (L' ++ D') <->
   exists n, seq (LJTheoryCut n)
         (LEncode L ++ REncode L')
         (LEncode D ++ REncode D') (UP []).
Proof with sauto.   
    intros.
    Admitted.
  
    
 Lemma asas A B C D : LJSeqC (A++B) (C++D) -> LJSeq (A++B) (C++D).
 Proof with sauto.
 intros.
 apply AdequacyLJ' in H...
 generalize (OLCutElimination wellTheory_p);intros.
 apply AdequacyLJ...
 
 Check OLCutElimination.
 
    assert(exists n, (OLTheoryCut PN n)⊢ ⌞ A ⌟ ++ ⌜ C ⌝; ⌞ B ⌟ ++ ⌜ D ⌝ ⇑ []). admit.
      destruct H1.
      apply H0 in H1.
      apply AdequacyLJ...
      5:{
      inversion H1...
      3:{ inversion H3...
            inversion H5...
       generalize wellFormedTheory_p.
          intros.
          destruct H2. 
      
        


