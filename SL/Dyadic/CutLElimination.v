Require Export LL.SL.Dyadic.OSTactics.
Set Implicit Arguments.

Section CutLElimination.
  Context `{OLS: OLSig}.

Theorem CutL i j w h C M N B : CutH w (i+j) -> CutW w -> complexity C = S w -> S h = i + j ->
 LL2 i |-- B; C::M ->
 LL2 j |-- B; (dual C)::N ->
 LL2 |-- B; M ++ N.
Proof with sauto; try dualSimpl.   
 intros CH CW compC hH Hi Hj.
 inversion Hi;subst.
 * checkPermutationCases H...
   solvell2.
   inversion H...
   solvell2.
 * inversion Hj...
   - checkPermutationCases H.
   - checkPermutationCases H.
     checkPermutationCases H.
     rewrite H3.
     rewrite <- H4.
     LL2tensor F G x0 N0;try solvell2.
     rewrite H in H0. 
     putFirst H0 Bot. 
     cutH H0 Hi... applyCutH. 
     unfold CutH in CH.
     eapply CH.
 
     rewrite H3.
     rewrite <- H4.
     LL2tensor F G M x0;try solvell2.
     rewrite H in H1.
     putFirst H1 Bot.
     cutH H1 Hi...
   - checkPermutationCases H.
     rewrite H2.
     LL2plus1 F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
   - checkPermutationCases H.
     rewrite H2.
     LL2plus2 F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
   - checkPermutationCases H.
     rewrite H1.
     LL2top x.
   - checkPermutationCases H.
     rewrite H3.
     solvell2.
     rewrite H2.
     LL2bot x;try solvell2.
     rewrite H in H0.
     cutH H0 Hi... exact Bot.
   - checkPermutationCases H.
     rewrite H2.
     LL2par F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
   - checkPermutationCases H.
     rewrite H3.
     LL2with F G x;try solvell2.
     rewrite H in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
     rewrite H in H1.
     putFirst H1 Bot.
     cutH H1 Hi...
   - checkPermutationCases H.
     rewrite H2.
     LL2store F x;try solvell2.
     rewrite H in H0.
     assert(LL2 n |-- F::B; Bot::x ->
            LL2 i |-- F::B; [One] ->
            LL2 |-- F::B; x++[]).
     eapply CH with (m := n + i)...
     rewrite app_nil_r in H1. 
     apply H1...
   - LL2copy F.
     simpl in H0.
     putFirst H0 Bot.
     cutH H0 Hi...
   - checkPermutationCases H.
     rewrite H4.
     LL2exist t FX x.
     rewrite H in H2.
     putFirst H2 Bot.
     cutH H2 Hi...
   - checkPermutationCases H.
     rewrite H3.
     LL2forall FX x. 
     apply H1 in H2.
     rewrite H in H2.
     putFirst H2 Bot.
     cutH H2 Hi...
 * checkPermutationCases H.
   - inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H6.
       rewrite <- H7.
       LL2tensor F0 G0 (M++x0) N1;try solvell2.
       rewrite H in H2...
       putFirst H2 (F ^ ⅋ G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     
       rewrite H6.
       rewrite <- H7.
       LL2tensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H3...
       putFirst H3 (F ^ ⅋ G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2plus1 F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (F ^ ⅋ G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2plus2 F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (F ^ ⅋ G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H5.
       LL2bot (M++x).
       rewrite H in H2...
       cutH Hi H2...
     + checkPermutationCases H.
       inversion H5...
       rewrite H6.
       rewrite H4.
       
       assert(LL2 n |-- B; F :: M0 ->
            LL2 n0 |-- B; F ^::(G ^::M1) ->
            LL2 |-- B; M0++(G ^::M1)).
       eapply CW with (m:=complexity F)... 
       inversion compC...
       assert(LL2 |-- B; M0 ++ G ^ :: M1).
       apply H...
       apply LL2StoLL2N in H3...
       rewrite <- Permutation_middle in H3.
       cutW H1 H3...
       inversion compC...
       rewrite (Permutation_app_comm M0).
       rewrite app_assoc_reverse.
       apply WCUT...
       
       rewrite H5.
       LL2par F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (F ^ ⅋ G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LL2with F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (F ^ ⅋ G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       
       rewrite H in H3.
       putFirst H3 (F ^ ⅋ G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2store F0 (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F0::B; (F ** G) :: M ->
            LL2 n0 |-- F0::B; (F ** G)^::x ->
            LL2 |-- F0::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H3...
       apply LL2weakeningN...
     + LL2copy F0.
       putFirst H2 (dual (F ** G)).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H7.
       LL2exist t FX (M++x).
       rewrite H in H5.
       putFirst H5 (F ^ $ G ^).
       cutH Hi H5...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LL2forall FX (M++x).
       apply H3 in H5.
       rewrite H in H5.
       putFirst H5 (F ^ $ G ^).
       cutH Hi H5...
       rewrite <- Permutation_midle...
   - rewrite H3.
     checkPermutationCases H.
     + LL2tensor F G (N++x0) N0;try solvell2.
       rewrite <- H4...
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj...
       rewrite Permutation_app_comm...
     + LL2tensor F G M0 (N++x0);try solvell2.
       rewrite <- H4...
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj...
       rewrite Permutation_app_comm...
 * checkPermutationCases H...
 
   2:{ rewrite H2.
       LL2plus1 F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (F ^ & G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus1 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus2 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H3.
       LL2bot (M++x).
       rewrite H in H1...
       cutH Hi H1...
     + checkPermutationCases H.
       rewrite H3. 
       LL2par F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4... 
       rewrite H5.
       cutW H0 H1...
       inversion compC...
       rewrite H4.
       LL2with F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (F ^ & G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2store F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F op G) :: M ->
            LL2 n0 |-- F0::B; (F op G)^::x ->
            LL2 |-- F0::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H2...
       apply LL2weakeningN...
     + LL2copy F0.
       putFirst H1 (dual (F op G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2exist t FX (M++x).
       rewrite H in H3.
       putFirst H3 (F ^ & G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2forall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 (F ^ & G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
 
   2:{ rewrite H2.
       LL2plus2 F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (F ^ & G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus1 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus2 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H3.
       LL2bot (M++x).
       rewrite H in H1...
       cutH Hi H1...
     + checkPermutationCases H.
       rewrite H3. 
       LL2par F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4... 
       rewrite H5.
       cutW H0 H2...
       inversion compC...
       rewrite H4.
       LL2with F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ & G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (F ^ & G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2store F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F op G) :: M ->
            LL2 n0 |-- F0::B; (F op G)^::x ->
            LL2 |-- F0::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H2...
       apply LL2weakeningN...
     + LL2copy F0.
       putFirst H1 (dual (F op G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2exist t FX (M++x).
       rewrite H in H3.
       putFirst H3 (F ^ & G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2forall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 (F ^ & G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
  * inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G x0 N0;try solvell2.
       rewrite H in H0...
       putFirst H0 (? F ^ ).
       cutH Hi H0...
       
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G M x0;try solvell2.
       rewrite H in H1...
       putFirst H1 (? F ^).
       cutH Hi H1...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus1 F0 G x.
       rewrite H in H0...
       putFirst H0 (? F ^).
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus2 F0 G x.
       rewrite H in H0...
       putFirst H0 (? F ^).
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H1.
       LL2top x.
     + checkPermutationCases H.
       rewrite H3.
       LL2bot x.
       rewrite H in H0...
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H3. 
       LL2par F0 G x.
       rewrite H in H0.
       putFirst H0 (? F ^).
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H4.
       LL2with F0 G x.
       rewrite H in H0.
       putFirst H0 (? F ^).
       cutH Hi H0...
       rewrite H in H1.
       putFirst H1 (? F ^).
       cutH Hi H1...
     + checkPermutationCases H.
       inversion H3...
       assert(LL2 n0 |-- F ^ :: B; M ->
            LL2 S n |-- B; [! F ^ ^] ->
            LL2 |-- B; M++[]).
       eapply CH with (C:=? F ^) (m := n0 + S n)...
       rewrite DualComplexity.
       simpl. rewrite <- ng_involutive...
       rewrite H4...
       
       rewrite H3.
       LL2store F0 x.
       rewrite H in H0.
       eapply @LL2weakeningN with (F:=F0) in Hi. 
       cutH Hi H0...
     + LL2copy F0.
       putFirst H0 (dual (! F)).
       cutH Hi H0...
     + checkPermutationCases H.
       rewrite H5.
       LL2exist t FX x.
       rewrite H in H3.
       putFirst H3 (? F ^).
       cutH Hi H3...
     + checkPermutationCases H.
       rewrite H4.
       LL2forall FX x.
       apply H1 in H3.
       rewrite H in H3.
       putFirst H3 (? F ^).
       cutH Hi H3...
 * checkPermutationCases H...
 
   2:{ rewrite H1.
       rewrite <- app_comm_cons...
       LL2top (x++N). }
   clear H2.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H3.
       rewrite <- H4.
       LL2tensor F G (M++x0) N0;try solvell2.
       rewrite H in H0...
       putFirst H0 zero.
       cutH Hi H0...
       rewrite <- Permutation_midle...
     
       rewrite H3.
       rewrite <- H4.
       LL2tensor F G M1 (M++x0);try solvell2.
       rewrite H in H1...
       putFirst H1 zero.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2plus1 F G (M++x).
       rewrite H in H0...
       putFirst H0 zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2plus2 F G (M++x).
       rewrite H in H0...
       putFirst H0 zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H1.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H2.
       LL2bot (M++x).
       rewrite H in H0...
       cutH Hi H0...
       exact zero.
     + checkPermutationCases H.
       rewrite H2. 
       LL2par F G (M++x).
       rewrite H in H0.
       putFirst H0 zero. 
       cutH Hi H0...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2with F G (M++x).
       rewrite H in H0.
       putFirst H0 zero.
       cutH Hi H0...
       rewrite <- Permutation_midle...
       rewrite H in H1.
       putFirst H1 zero.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2store F (M++x).
       rewrite H in H0.
       assert(LL2 i |-- F::B; top :: M ->
            LL2 n |-- F::B; top^::x ->
            LL2 |-- F::B; M++x).
       eapply CH with (m := i + n)...
       apply H1...
       apply LL2weakeningN...
     + LL2copy F.
       putFirst H0 (dual top).
       cutH Hi H0...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2exist t FX (M++x).
       rewrite H in H2.
       putFirst H2 zero.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2forall FX (M++x).
       apply H1 in H2.
       rewrite H in H2.
       putFirst H2 zero.
       cutH Hi H2...
       rewrite <- Permutation_midle...       
 * checkPermutationCases H...
   
   2:{ rewrite H2.
       LL2bot (x++N).
       rewrite H in H0.
       cutH H0 Hj... }
       
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + solvell2. 
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LL2tensor F G (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 one.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LL2tensor F G M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 one.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus1 F G (M++x).
       rewrite H in H1...
       putFirst H1 one.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus2 F G (M++x).
       rewrite H in H1...
       putFirst H1 one.
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H3.
       LL2bot (M++x).
       rewrite H in H1...
       cutH Hi H1... exact bot.
     + checkPermutationCases H.
       rewrite H3. 
       LL2par F G (M++x).
       rewrite H in H1.
       putFirst H1 one.
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2with F G (M++x).
       rewrite H in H1.
       putFirst H1 one.
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 one.
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2store F (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F::B; bot :: M ->
            LL2 n0 |-- F::B; bot^::x ->
            LL2 |-- F::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H2...
       apply LL2weakeningN...
     + LL2copy F.
       putFirst H1 (dual bot).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2exist t FX (M++x).
       rewrite H in H3.
       putFirst H3 one.
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2forall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 one.
       cutH Hi H3...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
 
   2:{ rewrite H2.
       LL2par F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       inversion H4...
       rewrite H5.
       
       assert(LL2 n |-- B; F ::(G ::M) ->
              LL2 n0 |-- B; F ^ :: M1 ->
              LL2 |-- B; (G ::M)++M1).
       eapply CW with (m:=complexity F)... 
       inversion compC...
       assert(LL2 |-- B; (G :: M) ++ M1).
       apply H...
       apply LL2StoLL2N in H3...
       rewrite <- app_comm_cons in H3.
       cutW H3 H2...
       inversion compC...
       rewrite app_assoc. 
       apply WCUT...
       
       checkPermutationCases H.
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H1...
       putFirst H1 (F ^ ** G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     
       rewrite H4.
       rewrite <- H5.
       LL2tensor F0 G0 M1 (M++x0);try solvell2.
       rewrite H in H2...
       putFirst H2 (F ^ ** G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus1 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ ** G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2plus2 F0 G0 (M++x).
       rewrite H in H1...
       putFirst H1 (F ^ ** G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H2.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H3.
       LL2bot (M++x).
       rewrite H in H1...
       cutH Hi H1...
     + checkPermutationCases H.
       rewrite H3. 
       LL2par F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ ** G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2with F0 G0 (M++x).
       rewrite H in H1.
       putFirst H1 (F ^ ** G ^).
       cutH Hi H1...
       rewrite <- Permutation_midle...
       rewrite H in H2.
       putFirst H2 (F ^ ** G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2store F0 (M++x).
       rewrite H in H1.
       assert(LL2 S n |-- F0::B; (F $ G) :: M ->
            LL2 n0 |-- F0::B; (F $ G)^::x ->
            LL2 |-- F0::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H2...
       apply LL2weakeningN...
     + LL2copy F0.
       putFirst H1 (dual (F $ G)).
       cutH Hi H1...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2exist t FX (M++x).
       rewrite H in H3.
       putFirst H3 (F ^ ** G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2forall FX (M++x).
       apply H2 in H3.
       rewrite H in H3.
       putFirst H3 (F ^ ** G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
 
   2:{ rewrite H3.
       LL2with F G (x++N).
       rewrite H in H0.
       putFirst H0 C.
       cutH H0 Hj...
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj... }
   rewrite <- H4 in H0.
   rewrite <- H4 in H1.
   clear H4.
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H5.
       rewrite <- H6.
       LL2tensor F0 G0 (M++x0) N0;try solvell2.
       rewrite H in H2.
       putFirst H2 (F ^ op G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H5.
       rewrite <- H6.
       LL2tensor F0 G0  M1 (M++x0);try solvell2.
       rewrite H in H3.
       putFirst H3 (F ^ op G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4...
       cutW H0 H2...
       inversion compC...
       rewrite H5...
       rewrite H4.
       LL2plus1 F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (F ^ op G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H4...
       cutW H1 H2...
       inversion compC...
       rewrite H5...
       rewrite H4.
       LL2plus2 F0 G0 (M++x).
       rewrite H in H2...
       putFirst H2 (F ^ op G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H4.
       LL2bot (M++x).
       rewrite H in H2...
       cutH Hi H2...
     + checkPermutationCases H.
       rewrite H4. 
       LL2par F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (F ^ op G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2with F0 G0 (M++x).
       rewrite H in H2.
       putFirst H2 (F ^ op G ^).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H in H3.
       putFirst H3 (F ^ op G ^).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2store F0 (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F0::B; (F & G) :: M ->
            LL2 n0 |-- F0::B; (F & G)^::x ->
            LL2 |-- F0::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H3...
       apply LL2weakeningN...
     + LL2copy F0.
       putFirst H2 (dual (F & G)).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LL2exist t FX (M++x).
       rewrite H in H4.
       putFirst H4 (F ^ op G ^).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2forall FX (M++x).
       apply H3 in H4.
       rewrite H in H4.
       putFirst H4 (F ^ op G ^).
       cutH Hi H4...
       rewrite <- Permutation_midle...      
 * checkPermutationCases H...
   
   2:{ rewrite H2.
       LL2store F (x++N).
       rewrite H in H0.
       apply @LL2weakeningN with (F:=F) in Hj.
       cutH H0 Hj... }
   rewrite <- H3 in H0.
   clear H3.
     assert(LL2 n |-- F::B; M ->
            LL2 j |-- B; (? F) ^::N ->
            LL2 |-- B; M++N).
     eapply CH with (m := n + j) (C:=? F)...
     apply H...    
 * LL2copy F. 
   putFirst H0 C.
   cutH H0 Hj...
 * checkPermutationCases H...
   2:{ rewrite H4.
       LL2exist t FX (x++N).
       rewrite H in H2.
       putFirst H2 C.
       cutH H2 Hj... }
   rewrite <- H5 in H2.
   clear H5.   
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H6.
       rewrite <- H7.
       LL2tensor F G (M++x0) N0;try solvell2.
       rewrite H in H3.
       putFirst H3 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
       rewrite H6.
       rewrite <- H7.
       LL2tensor F G  M1 (M++x0);try solvell2.
       rewrite H in H4.
       putFirst H4 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5...
       LL2plus1 F G (M++x).
       rewrite H in H3...
       putFirst H3 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5...
       LL2plus2 F G (M++x).
       rewrite H in H3...
       putFirst H3 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H5.
       LL2bot (M++x).
       rewrite H in H3...
       cutH Hi H3...
     + checkPermutationCases H.
       rewrite H5. 
       LL2par F G (M++x).
       rewrite H in H3.
       putFirst H3 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H6.
       LL2with F G (M++x).
       rewrite H in H3.
       putFirst H3 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
       rewrite H in H4.
       putFirst H4 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2store F (M++x).
       rewrite H in H3.
       assert(LL2 S n |-- F::B; E{ FX} :: M ->
            LL2 n0 |-- F::B; E{ FX} ^ ::x ->
            LL2 |-- F::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H4...
       apply LL2weakeningN...
     + LL2copy F.
       putFirst H3 (dual (E{ FX})).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H7.
       LL2exist t0 FX0 (M++x).
       rewrite H in H5.
       putFirst H5 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H5...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       inversion H6...
       assert(proper t) by auto.
       specialize (H4 _ H1).
       cutW H2 H4...
       inversion compC...
       assert(proper (VAR con 0)).
       apply proper_VAR.
       eapply @ComplexityUniformEq with (FX:=FX) (x:=t) in H1...
       rewrite H7... 
       
       rewrite H6.
       LL2forall FX0 (M++x).
       specialize (H4 _ H5).
       rewrite H in H4.
       putFirst H4 (F{ fun x : expr con => (FX x) ^}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
 * checkPermutationCases H...
   2:{ rewrite H3.
       LL2forall FX (x++N).
       specialize (H1 _ H2).
       rewrite H in H1.
       putFirst H1 C.
       cutH H1 Hj... }
   assert(Hn1 : forall x : expr con,
     proper x -> LL2 n |-- B; FX x :: M).    
   intros.
   specialize (H1 _ H).     
   rewrite H4...
   clear H4 H1.
   rename Hn1 into H1.   
   inversion Hj...
     + checkPermutationCases H.
     + checkPermutationCases H.
       checkPermutationCases H.
       rewrite H5.
       rewrite <- H6.
       LL2tensor F G (M++x0) N0;try solvell2.
       rewrite H in H2.
       putFirst H2 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H5.
       rewrite <- H6.
       LL2tensor F G  M1 (M++x0);try solvell2.
       rewrite H in H3.
       putFirst H3 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4...
       LL2plus1 F G (M++x).
       rewrite H in H2...
       putFirst H2 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4...
       LL2plus2 F G (M++x).
       rewrite H in H2...
       putFirst H2 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H3.
       LL2top (M++x).
     + checkPermutationCases H.
       rewrite H4.
       LL2bot (M++x).
       rewrite H in H2...
       cutH Hi H2... exact bot.
     + checkPermutationCases H.
       rewrite H4. 
       LL2par F G (M++x).
       rewrite H in H2.
       putFirst H2 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H2...
       rewrite <- Permutation_midle.
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2with F G (M++x).
       rewrite H in H2.
       putFirst H2 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H2...
       rewrite <- Permutation_midle...
       rewrite H in H3.
       putFirst H3 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H4.
       LL2store F (M++x).
       rewrite H in H2.
       assert(LL2 S n |-- F::B; F{ FX} :: M ->
            LL2 n0 |-- F::B; F{ FX} ^ ::x ->
            LL2 |-- F::B; M++x).
       eapply CH with (m := S n + n0)...
       apply H3...
       apply LL2weakeningN...
     + LL2copy F.
       putFirst H2 (dual (F{ FX})).
       cutH Hi H2...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H7.
       inversion H6...
       assert(proper t) by auto.
       specialize (H1 _ H3). 
       cutW H1 H4...
       inversion compC...
       assert(proper (VAR con 0)).
       apply proper_VAR.
       eapply @ComplexityUniformEq with (FX:=FX) (x:=t) in H3...
       
       rewrite H6.
       LL2exist t FX0 (M++x).
       rewrite H in H4.
       putFirst H4 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H4...
       rewrite <- Permutation_midle...
     + checkPermutationCases H.
       rewrite H5.
       LL2forall FX0 (M++x).
       specialize (H3 _ H4).
       rewrite H in H3.
       putFirst H3 (E{ fun x : expr con => (FX x) ^}).
       cutH Hi H3...
       rewrite <- Permutation_midle...
Qed.              
     
End CutLElimination.
